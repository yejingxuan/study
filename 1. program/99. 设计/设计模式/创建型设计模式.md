# 六种创建型设计模式

>参考文章：https://blog.csdn.net/zhangerqing/article/details/8194653

- [六种创建型设计模式](#%e5%85%ad%e7%a7%8d%e5%88%9b%e5%bb%ba%e5%9e%8b%e8%ae%be%e8%ae%a1%e6%a8%a1%e5%bc%8f)
  - [一、单例模式](#%e4%b8%80%e5%8d%95%e4%be%8b%e6%a8%a1%e5%bc%8f)
  - [二、简单工厂](#%e4%ba%8c%e7%ae%80%e5%8d%95%e5%b7%a5%e5%8e%82)
  - [三、工厂模式](#%e4%b8%89%e5%b7%a5%e5%8e%82%e6%a8%a1%e5%bc%8f)
  - [四、抽象工厂](#%e5%9b%9b%e6%8a%bd%e8%b1%a1%e5%b7%a5%e5%8e%82)
  - [五、原型模式（Prototype）](#%e4%ba%94%e5%8e%9f%e5%9e%8b%e6%a8%a1%e5%bc%8fprototype)
  - [六、建造者模式](#%e5%85%ad%e5%bb%ba%e9%80%a0%e8%80%85%e6%a8%a1%e5%bc%8f)

## 一、单例模式

__完美单例：__

```java
public class SingletonTest {
 
    private static SingletonTest instance = null;
 
    private SingletonTest() {
    }
 
    private static synchronized void syncInit() {
        if (instance == null) {
            instance = new SingletonTest();
        }
    }
 
    public static SingletonTest getInstance() {
        if (instance == null) {
            syncInit();
        }
        return instance;
    }
}
```
完美单例并不完美，只想理想状态下的完美。
- 1、反射可以跨过private权限，获取到构造函数，来生成新的对象——解决方案：在构造函数里再加上一层判断
    ```java
    private SingletonTest() {
        if (instance != null) {
            return instance;
        }
    }
    ```
- 2、序列化可以通过流的方式生成新的对象——解决方案：
重写readUnshared()方法，反序列化时会调用该方法，返回对象引用即可
    ```java
    private  Object readResolve(){
        return instance;
    }
    ```

## 二、简单工厂




## 三、工厂模式




## 四、抽象工厂




## 五、原型模式（Prototype）

>原型模式虽然是创建型的模式，但是与工程模式没有关系，从名字即可看出，该模式的思想就是将一个对象作为原型，对其进行复制、克隆，产生一个和原对象类似的新对象


```java

public class Prototype implements Cloneable, Serializable {
 
    private static final long serialVersionUID = 1L;
    private String string;
 
    private SerializableObject obj;
 
    /* 浅复制 */
    public Object clone() throws CloneNotSupportedException {
        Prototype proto = (Prototype) super.clone();
        return proto;
    }
 
    /* 深复制 */
    public Object deepClone() throws IOException, ClassNotFoundException {
 
        /* 写入当前对象的二进制流 */
        ByteArrayOutputStream bos = new ByteArrayOutputStream();
        ObjectOutputStream oos = new ObjectOutputStream(bos);
        oos.writeObject(this);
 
        /* 读出二进制流产生的新对象 */
        ByteArrayInputStream bis = new ByteArrayInputStream(bos.toByteArray());
        ObjectInputStream ois = new ObjectInputStream(bis);
        return ois.readObject();
    }
 
    public String getString() {
        return string;
    }
 
    public void setString(String string) {
        this.string = string;
    }
 
    public SerializableObject getObj() {
        return obj;
    }
 
    public void setObj(SerializableObject obj) {
        this.obj = obj;
    }
 
}

```






## 六、建造者模式


> 工厂类模式提供的是创建单个类的模式，而建造者模式则是将各种产品集中起来进行管理，用来创建复合对象，所谓复合对象就是指某个类具有不同的属性，

建造者模式将很多功能集成到一个类里，这个类可以创造出比较复杂的东西。

所以与工程模式的区别就是：工厂模式关注的是创建单个产品，而建造者模式则关注创建符合对象，多个部分。因此，是选择工厂模式还是建造者模式，依实际情况而定。

```java
public class Builder {
    
    private List<Sender> list = new ArrayList<Sender>();
    
    public void produceMailSender(int count){
        for(int i=0; i<count; i++){
            list.add(new MailSender());
        }
    }
    
    public void produceSmsSender(int count){
        for(int i=0; i<count; i++){
            list.add(new SmsSender());
        }
    }
}
```


