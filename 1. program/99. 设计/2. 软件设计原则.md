# 软件设计原则

- [软件设计原则](#软件设计原则)
  - [一、七种设计原则](#一七种设计原则)
    - [1. 单一职责原则](#1-单一职责原则)
    - [2. 开闭原则](#2-开闭原则)
    - [3. 里氏代换原则](#3-里氏代换原则)
    - [4. 依赖倒转原则](#4-依赖倒转原则)
    - [5. 接口隔离原则](#5-接口隔离原则)
    - [6. 合成复用原则](#6-合成复用原则)
    - [7. 迪米特原则](#7-迪米特原则)
  - [参考文章](#参考文章)



## 一、七种设计原则

__开闭原则是目标，里氏代换原则是基础，依赖倒转原则是手段__

-------------------

### 1. 单一职责原则
> 单一职责原则(Single Responsibility Principle, SRP)：一个类只负责一个功能领域中的相应职责，或者可以定义为：就一个类而言，应该只有一个引起它变化的原因。

(1) 单一职责原则以实现高内聚,低耦合为目标的大前提下的对类进行功能责任制的思想



### 2. 开闭原则

> 开闭原则(Open-Closed Principle, OCP)：一个软件实体应当对扩展开放，对修改关闭。即软件实体应尽量在不修改原有代码的情况下进行扩展。

(1) 开放-封闭原则，尽量的对修改封闭，因为修改需要耗费很多的时间，而且工作强度大，而要对扩展开放，假如真的要修改，可以在原有的基础上增加其功能，让其实现。


### 3. 里氏代换原则

> 里氏代换原则(Liskov Substitution Principle, LSP)：所有引用基类（父类）的地方必须能透明地使用其子类的对象。

(1)  子类可以替换父类，父类不能替换子类。


### 4. 依赖倒转原则
> 依赖倒转原则(Dependency Inversion  Principle, DIP)：抽象不应该依赖于细节，细节应当依赖于抽象。换言之，要针对接口编程，而不是针对实现编程。


定义：高层模块不应该依赖低层模块，二者都应该依赖其抽象；抽象不应该依赖细节；细节应该依赖抽象。

问题由来：类A直接依赖类B，假如要将类A改为依赖类C，则必须通过修改类A的代码来达成。这种场景下，类A一般是高层模块，负责复杂的业务逻辑；类B和类C是低层模块，负责基本的原子操作；假如修改类A，会给程序带来不必要的风险。

解决方案：将类A修改为依赖接口I，类B和类C各自实现接口I，类A通过接口I间接与类B或者类C发生联系，则会大大降低修改类A的几率。

(1) 依赖倒置原则的核心思想是面向接口编程，



### 5. 接口隔离原则

>接口隔离原则(Interface  Segregation Principle, ISP)：使用多个专门的接口，而不使用单一的总接口，即客户端不应该依赖那些它不需要的接口。

(1) 接口隔离原则由单一职责原则演化而来。职责单一不一定指只定义一个方法，指的是功能性或模块性的一致性


### 6. 合成复用原则

> 合成复用原则(Composite Reuse Principle, CRP)：尽量使用对象组合，而不是继承来达到复用的目的。


(1) 多用关联少用继承,继承的耦合性太强, 也就是 __高内聚__

### 7. 迪米特原则

> 迪米特法则(Law of  Demeter, LoD)：一个软件实体应当尽可能少地与其他实体发生相互作用。

(1) 应该尽量减少对象之间的交互，如果两个对象之间不必彼此直接通信，那么这两个对象就不应当发生任何直接的相互作用，如果其中的一个对象需要调用另一个对象的某一个方法的话，可以通过第三者转发这个调用。简言之，就是通过引入一个合理的第三者来降低现有对象之间的耦合度。

(2) 降低系统的耦合度，使类与类之间保持松散的耦合关系, 也就是 __低耦合__


## 参考文章
- https://blog.csdn.net/lovelion/article/details/17517213?tdsourcetag=s_pctim_aiomsg  
https://blog.csdn.net/zhengzhb/article/details/7289269