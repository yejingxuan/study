# 分布式进阶

- [分布式进阶](#分布式进阶)
  - [一、分布式协调服务之ZooKeeper](#一分布式协调服务之zookeeper)
    - [1.1、结构原理](#11结构原理)
    - [1.2、ZAB协议](#12zab协议)
    - [1.3、选主投票机制](#13选主投票机制)
    - [1.4、应用场景](#14应用场景)
  - [二、分布式协调服务之eureka](#二分布式协调服务之eureka)
  - [三、分布式事务](#三分布式事务)
    - [3.1、XA 方案](#31xa-方案)
    - [3.2、TCC方案](#32tcc方案)
    - [3.3、本地消息表](#33本地消息表)
    - [3.4、可靠消息最终一致性方案](#34可靠消息最终一致性方案)
    - [3.5、最大努力通知方案](#35最大努力通知方案)
    - [3.6、总结](#36总结)
  - [四、分布式锁](#四分布式锁)
  - [五、分布式限流](#五分布式限流)
  - [六、分布式开发框架之springboot](#六分布式开发框架之springboot)
    - [6.1、自动装配 && starter](#61自动装配--starter)
    - [6.2、springboot配置的优先级](#62springboot配置的优先级)
  - [参考文章](#参考文章)

## 一、分布式协调服务之ZooKeeper

### 1.1、结构原理

  - __存储结构图__
    ![](https://gitee.com/jingxuanye/yjx-pictures/raw/master/pic/20200429162023.png)
    - /master：存储主节点的信息，若在主从模式中其没有数据，代表分布式应用的主节点还没有被选举出来。
    - /workers：下面的每个子 znode 代表一个从节点。
    - /tasks：下面的每个子 znode 代表一个任务，znode 上存储的信息代表着任务内容。
    - /assign：下面每个子 znode 代表一个从节点的任务集合。/assign/worker-1 代表从节点 worker-1 的任务集合，其下面的子 znode 都是分配给 worker-1 的任务。

  - __ZK角色__
    - leader：领导者。leader 作为整个 ZooKeeper 集群的主节点，负责响应所有对 ZooKeeper
    状态变更的请求。它会将每个状态更新请求进行排序和编号，以便保证整个集群内部消息处理的FIFO 。eader 为客户端提供读和写服务。

    - follower：追随者。follower 除了需要响应本服务器上的读请求外，还要处理 leader 的提议，并在 leader 提交提议时在本地也进行提交。需要注意的是，leader 和 follower 共同构成了 ZooKeeper 集群的法定人数，也就是说，只有他们才参与新 leader 的选举、响应 leader 的提议。

    - observer：观察者。若 ZooKeeper 集群的读取负载很高，可以设置一些 observer 服务器，以提高读取的吞吐量。observer 和 follower 比较相似，但还是具有两个区别：一是 observer 不属于法定人数，即不参加选举也不响应提议；二是 observer 不需要将事务持久化到磁盘，一旦 observer 被重启，需要从 leader 重新同步整个名字空间。需要注意，一个 ZooKeeper 集群同一时刻只会有一个 Leader，其他都是 Follower 或 Observer。

### 1.2、ZAB协议
  
- Zab 协议有两种模式：它们分别是恢复模式（选主）和广播模式（同步）。当服务启动或者在领导者崩溃后，Zab 就进入了恢复模式，当领导者被选举出来，且大多数 Server 完成了和 leader 的状态同步以后，恢复模式就结束了。状态同步保证了 leader 和 Server 具有相同的系统状态

### 1.3、选主投票机制
  
- __选主流程：__

  目前有 5 台服务器，每台服务器均没有数据，它们的编号分别是 1,2,3,4,5,按编号依次启动，它们的选择举过程如下：
  1. 服务器 1 启动，给自己投票，然后发投票信息，由于其它机器还没有启动所以它收不到反
  馈信息，服务器 1 的状态一直属于 Looking。
  2. 服务器 2 启动，给自己投票，同时与之前启动的服务器 1 交换结果，由于服务器 2 的编号
  大所以服务器 2 胜出，但此时投票数没有大于半数，所以两个服务器的状态依然是
  LOOKING。
  3. 服务器 3 启动，给自己投票，同时与之前启动的服务器 1,2 交换信息，由于服务器 3 的编
  号最大所以服务器 3 胜出，此时投票数正好大于半数，所以服务器 3 成为领导者，服务器
  1,2 成为小弟。
  4. 服务器 4 启动，给自己投票，同时与之前启动的服务器 1,2,3 交换信息，尽管服务器 4 的
  编号大，但之前服务器 3 已经胜出，所以服务器 4 只能成为小弟。
  5. 服务器 5 启动，后面的逻辑同服务器 4 成为小弟


### 1.4、应用场景
- __分布式协调__
- __分布式锁__
- __元数据/配置信息管理__
- __HA高可用性__




## 二、分布式协调服务之eureka


## 三、分布式事务



### 3.1、XA 方案

- __原理__
  - 所谓的 XA 方案，即：两阶段提交。有一个事务管理器的概念，负责协调多个数据库（资源管理器）的事务，事务管理器先问问各个数据库你准备好了吗？如果每个数据库都回复 ok，那么就正式提交事务，在各个数据库上执行操作；如果任何其中一个数据库回答不 ok，那么就回滚事务
  - spring+JPA就可以实现
- __流程__
  - 第一阶段：询问
  - 第二阶段：执行


- __适应场景__
  - 比较适合单块应用里，跨多个库的分布式事务，而且因为严重依赖于数据库层面来搞定复杂的事务，效率很低，绝对不适合高并发的场景
  - 为什么呢？因为对于一个数据库来说，只需要判断一次能不能执行就OK了，再判断的话完全属于资源浪费


### 3.2、TCC方案

- __原理__
  - TCC 的全称是：Try、Confirm、Cancel。
  - 这种方案说实话几乎很少人使用，我们用的也比较少，但是也有使用的场景。因为这个事务回滚，资源锁定、实际上是严重依赖于你自己写代码来回滚和补偿了，会造成补偿代码巨大，非常之恶心

- __流程__
  - Try 阶段：这个阶段说的是对各个服务的 __资源做检测__ 以及 __对资源进行锁定或者预留__。
  - Confirm 阶段：这个阶段说的是在各个服务中执行实际的操作。
  - Cancel 阶段：如果任何一个服务的业务方法执行出错，那么这里就需要进行补偿，就是执行已经执行成功的业务逻辑的回滚操作。（把那些执行成功的回滚）

- __适应场景__
  - 一般来说跟钱相关的，跟钱打交道的，支付、交易相关的场景，我们会用 TCC，严格保证分布式事务要么全部成功，要么全部自动回滚，严格保证资金的正确性，保证在资金上不会出现问题
  - 最好是你的各个业务执行的时间都比较短



### 3.3、本地消息表
- __原理__
  - 本地消息表其实是国外的 ebay 搞出来的这么一套思想，主要利用消息表来记录ABC系统的执行状态

- __流程__
  ![](https://gitee.com/jingxuanye/yjx-pictures/raw/master/pic/20200529221016.png)

- __适应场景__
  - 这个方案说实话最大的问题就在于严重依赖于数据库的消息表来管理事务啥的，如果是高并发场景咋办呢？咋扩展呢？所以一般确实很少用。


### 3.4、可靠消息最终一致性方案

- __原理__

- __流程__

- __适应场景__


### 3.5、最大努力通知方案
- __原理__
  - 尽可能的通知B服务去执行

- __流程__
  - 系统 A 本地事务执行完之后，发送个消息到 MQ；
  - 有个专门消费 MQ 的最大努力通知服务，这个服务会消费 MQ 然后写入数据库中记录下来，或者是放入个内存队列也可以，接着调用系统 B 的接口；
  - 要是系统 B 执行成功就 ok 了；要是系统 B 执行失败了，那么最大努力通知服务就定时尝试重新调用系统 B，反复 N 次，最后还是不行就放弃

- __适应场景__
  - 不重要的事务场景，允许少量的失败，例如日志之类的

### 3.6、总结
- 任何一个分布式事务都会使代码复杂度复制10倍以上，而且降级系统的QPS和性能，99%的分布式接口调用，不要做分布式事务，



## 四、分布式锁




## 五、分布式限流



## 六、分布式开发框架之springboot

### 6.1、自动装配 && starter
- 通过springboot-starter来自动装配
- 开发自己的springboot-starter

### 6.2、springboot配置的优先级
- 我们都知道Spring Boot的配置会从application.properties中读取。实际上，从resource目录下的application.properties文件读取是Spring Boot配置链中的一环而已。

- Spring Boot 提供了一种统一的方式来管理应用的配置，允许开发人员使用 __属性文件、YAML 文件、环境变量和命令行参数__ 来定义优先级不同的配置值

- __配置优先级从大到小的顺序__

  1.命令行参数

  2.java:comp/env 里的 JNDI 属性

  3.JVM 系统属性

  4.操作系统环境变量

  5.RandomValuePropertySource 属性类生成的 random.* 属性

  6.应用以外的 application.properties（或 yml）文件

  7.打包在应用内的 application.properties（或 yml）文件

  8.在应用 @Configuration 配置类中，用 @PropertySource 注解声明的属性文件

  9.SpringApplication.setDefaultProperties 声明的默认属性

## 参考文章
- [好好地说一次,自定义springboot-starter开发(从配置到单元测试)](https://zhuanlan.zhihu.com/p/80326855)
