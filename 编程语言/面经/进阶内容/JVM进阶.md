# JVM进阶

- [JVM进阶](#jvm进阶)
  - [一、JVM(java virtual machine)](#一jvmjava-virtual-machine)
    - [1.1、JVM划分](#11jvm划分)
    - [1.2、Java 堆内存从 GC 的角度还可以细分为](#12java-堆内存从-gc-的角度还可以细分为)
  - [二、JVM执行过程](#二jvm执行过程)
    - [2.1、类加载过程](#21类加载过程)
    - [2.2、双亲委派机制](#22双亲委派机制)
    - [2.3、对象创建过程](#23对象创建过程)
    - [2.4、逃逸分析](#24逃逸分析)
  - [三、JMM(java memory model)](#三jmmjava-memory-model)
    - [3.1、对象在内存中的存储布局](#31对象在内存中的存储布局)
    - [3.2、对象定位方法](#32对象定位方法)
  - [四、GC垃圾回收](#四gc垃圾回收)
    - [4.1、垃圾标记算法](#41垃圾标记算法)
    - [4.2、java的四种引用](#42java的四种引用)
    - [4.3、垃圾回收算法](#43垃圾回收算法)
    - [4.4、垃圾回收器](#44垃圾回收器)
    - [4.5、垃圾回收什么时候执行？](#45垃圾回收什么时候执行)
    - [4.6、内存泄露](#46内存泄露)
    - [4.7、内存溢出](#47内存溢出)
  - [五、JVM调优](#五jvm调优)
    - [5.1、内存区域大小分配](#51内存区域大小分配)
    - [5.2、垃圾回收器设置](#52垃圾回收器设置)
    - [5.3、参数预估](#53参数预估)
    - [5.4、JVM的OOM问题排查](#54jvm的oom问题排查)
  - [六、JDK1.8改进](#六jdk18改进)
    - [6.1、内存空间改进](#61内存空间改进)
  - [参考文章](#参考文章)


## 一、JVM(java virtual machine)

### 1.1、JVM划分

![](https://gitee.com/jingxuanye/yjx-pictures/raw/master/pic/20200526142425.png)

- __按内存区域来划分：__
  - __线程私有数据区域__ 生命周期与线程相同，依赖用户线程的启动/结束而创建/销毁
  - __线程共享区域__ 随虚拟机的启动/关闭而创建/销毁
  - __直接内存__ 并不是 JVM 运行时数据区的一部分, 但也会被频繁的使用: 在 JDK 1.4 引入的 NIO 提供了基于 Channel 与 Buffer 的 IO 方式, 它可以使用 Native 函数库直接分配堆外内存, 然后使用DirectByteBuffer 对象作为这块内存的引用进行操作(详见: Java I/O 扩展), 这样就避免了在 Java堆和 Native 堆中来回复制数据, 因此在一些场景中可以显著提高性能。

- __详细介绍：__
  - 虚拟机栈
    - Java 虚拟机栈是基于线程的。哪怕你只有一个 main() 方法，也是以线程的方式运行的。在线程的生命周期中，参与计算的数据会频繁地入栈和出栈，栈的生命周期是和线程一样的。
    - 每个方法在执行的同时都会创建一个栈帧（Stack Frame）用于存储局部变量表、操作数栈、动态链接、方法出口等信息。 每一个方法从调用直至执行完成的过程，就对应着一个栈帧在虚拟机栈中入栈到出栈的过程。
  
  - 本地方法栈
    - 本地方法区和 Java Stack 作用类似, 区别是虚拟机栈为执行 Java 方法服务, 而本地方法栈则为Native 方法服务, 如果一个 VM 实现使用 C-linkage 模型来支持 Native 调用, 那么该栈将会是一个C 栈，但 HotSpot VM 直接就把本地方法栈和虚拟机栈合二为一。

  - 程序计数器
    - 一块较小的内存空间, 是当前线程所执行的字节码的行号指示器，每条线程都要有一个独立的程序计数器，这类内存也称为“线程私有” 的内存
    - 正在执行 java 方法的话，计数器记录的是虚拟机字节码指令的地址（当前指令的地址） 。如果还是 Native 方法，则为空
    - 这个内存区域是唯一一个在虚拟机中没有规定任何 OutOfMemoryError 情况的区域

  - 堆
    - 是被线程共享的一块内存区域， 创建的对象和数组都保存在 Java 堆内存中，也是垃圾收集器进行垃圾收集的最重要的内存区域。 由于现代 VM 采用分代收集算法, 因此 Java 堆从 GC 的角度还可以细分为: 新生代(Eden 区、 From Survivor 区和 To Survivor 区)和老年代。

  - 方法区
    - 即我们常说的永久代(Permanent Generation), 用于存储被 JVM 加载的类信息、 常量、 静态变量、 即时编译器编译后的代码等数据。

### 1.2、Java 堆内存从 GC 的角度还可以细分为

![](https://gitee.com/jingxuanye/yjx-pictures/raw/master/pic/20200526134338.png)

- 新生代(位于堆中、细分为Eden 区、 From Survivor 区和 To Survivor 区)
  - 是用来存放新生的对象。一般占据堆的 1/3空间。由于频繁创建对象，所以新生代会频繁触发MinorGC 进行垃圾回收。
- 老年代（位于堆中）
  - 主要存放应用程序中生命周期长的内存对象。老年代的对象比较稳定，所以 MajorGC 不会频繁执行。
  - 引用计数法计算的对象年纪超过15后放入老年代，一些特别大的对象在s区放不下也会放到老年代
- 永久代（位于方法区）
  - 指内存的永久保存区域，主要存放 Class 和 Meta（元数据）的信息,Class 在被加载的时候被放入永久区域， 它和和存放实例的区域不同,GC 不会在主程序运行期对永久区域进行清理。所以这也导致了永久代的区域会随着加载的 Class 的增多而胀满，最终抛出 OOM 异常
  - 在 Java8 中， 永久代已经被移除，被一个称为“元数据区”（元空间）的区域所取代。元空间的本质和永久代类似，元空间与永久代之间最大的区别在于： 元空间并不在虚拟机中，而是使用本地内存
  - 元空间的好处也是它的坏处。使用非堆可以使用操作系统的内存，JVM 不会再出现方法区的内存溢出；但是，无限制的使用会造成操作系统的死亡。所以，一般也会使用参数-XX:MaxMetaspaceSize 来控制大小

## 二、JVM执行过程

### 2.1、类加载过程

![](https://gitee.com/jingxuanye/yjx-pictures/raw/master/pic/20200506161017.png)
- 加载：
  - 将外部的 .class 文件，加载到 Java 的方法区内。加载阶段主要是找到并加载类的二进制数据，比如从 jar 包里或者 war 包里找到它们。
- 验证：
  - 确保 Class 文件的字节流中包含的信息是否符合当前虚拟机的要求，并且不会危害虚拟机自身的安全。不符合规范的将抛出 java.lang.VerifyError 错误。
- 准备
  - 为一些类变量分配内存，并将其初始化为默认值。此时，实例对象还没有分配内存，所以这些动作是在方法区上进行的
- 解析：
  - 将符号引用替换为直接引用。符号引用是一种定义，可以是任何字面上的含义，而直接引用就是直接指向目标的指针、相对偏移量。解析阶段负责把整个类激活，串成一个可以找到彼此的网
- 初始化
  - 初始化成员变量，到了这一步，才真正开始执行一些字节码。

### 2.2、双亲委派机制
- __加载流程__
  - 当一个类收到了类加载请求，他首先不会尝试自己去加载这个类，而是把这个请求委派给父类去完成，每一个层次类加载器都是如此，因此所有的加载请求都应该传送到启动类加载其中，只有当父类加载器反馈自己无法完成这个请求的时候（在它的加载路径下没有找到所需加载的Class）， 子类加载器才会尝试自己去加载。

- __优点：__ 
  - __虚拟机只有在两个类的类名相同且加载该类的加载器均相同的情况下才判定这是一个类__。若不采用双亲委派机制，同一个类有可能被多个类加载器加载，这样该类会被识别为两个不同的类，相互赋值时会有问题。双亲委派机制能保证多加载器加载某个类时，最终都是由一个加载器加载，确保最终加载结果相同。

- __破坏双亲委派机制__
  - 线程上下文加载器(Thread Context ClassLoader)
  - 因为类加载器受到加载范围的限制，在某些情况下父类加载器无法加载到需要的文件，这时候就需要委托子类加载器去加载class文件。

  - 因为类加载器受到加载范围的限制，在某些情况下父类加载器无法加载到需要的文件，这时候就需要委托子类加载器去加载class文件。

  - JDBC的Driver接口定义在JDK中，其实现由各个数据库的服务商来提供，比如MySQL驱动包。DriverManager 类中要加载各个实现了Driver接口的类，然后进行管理，但是DriverManager位于$JAVA_HOME中jre/lib/rt.jar包，由BootStrap类加载器加载，而其Driver接口的实现类是位于服务商提供的 Jar 包，根据类加载机制，当被装载的类引用了另外一个类的时候，虚拟机就会使用装载第一个类的类装载器装载被引用的类。也就是说BootStrap类加载器还要去加载jar包中的Driver接口的实现类。我们知道，BootStrap类加载器默认只负责加载 $JAVA_HOME中jre/lib/rt.jar 里所有的class，所以需要由子类加载器去加载Driver实现，这就破坏了双亲委派模型。


### 2.3、对象创建过程
![](https://gitee.com/jingxuanye/yjx-pictures/raw/master/pic/20200526144233.png)

1. 遇到 new 指令时，首先检查这个指令的参数是否能在常量池中定位到一个类的符号引用，并且检查这个符号引用代表的类是否已经被加载、解析和初始化过。如果没有，执行相应的类加载。
2. 类加载检查通过之后，为新对象分配内存
3. 成员变量赋默认值（默认值一般为0或null）
4. 设置对象头，主要设置类的元数据信息、对象的哈希码、对象的GC分代年龄等信息。
5. 执行init方法初始化，给成员变量赋值初始值
6. 把栈空间和堆空间中的数据建立关联关系


### 2.4、逃逸分析

- __逃逸分析：__
  - 就是分析出对象的作用域。当一个对象在方法体内声明后，该对象的引用被其他外部所引用时该对象就发生了逃逸，反之就会在栈帧中为对象分配内存空间。
- __逃逸分析的目的：__
  - 为了提高GC的回收效率，对象实例的内存分配不一定必须存在于堆区中，还可采用堆外分配。而最常见的堆外分配就是采用逃逸分析筛选出未发生逃逸的对象，在栈帧中分配内存空间
  - 根据逃逸分析在栈帧中分配的对象内存，不会使用GC进行垃圾回收。因为栈会随着方法的开始而创建，结束而销毁


## 三、JMM(java memory model)

### 3.1、对象在内存中的存储布局
![](https://gitee.com/jingxuanye/yjx-pictures/raw/master/pic/20200526104203.png)

- __在 HotSpot 虚拟机中，分为 3 块区域：对象头(Header)、实例数据(Instance Data)和对齐填充(Padding)__

- __对象头(Header)：__ 
  - 第一部分用于存储对象自身的运行时数据，如哈希码、GC 分代年龄、锁状态标志、线程持有的锁、偏向线程 ID、偏向时间戳等，32 位虚拟机占 32 bit，64 位虚拟机占 64 bit。官方称为 ‘Mark Word’。
  - 第二部分是类型指针，即对象指向它的类的元数据指针，虚拟机通过这个指针确定这个对象是哪个类的实例。另外，如果是 Java 数组，对象头中还必须有一块用于记录数组长度的数据，因为普通对象可以通过 Java 对象元数据确定大小，而数组对象不可以。

- __实例数据(Instance Data)：__ 
  - 程序代码中所定义的各种类型的字段内容(包含父类继承下来的和子类中定义的)。

- __对齐填充(Padding)：__ 
  - 不是必然需要，主要是占位，保证对象大小是某个字节的整数倍。



### 3.2、对象定位方法
![](https://gitee.com/jingxuanye/yjx-pictures/raw/master/pic/20200526144637.png)

- 虚拟机如果使用句柄访问方式，Java堆中首先会划分出一块内存作为句柄池，这时候对象引用reference存储的就是对象的句柄地址而不是作为对象指针指向堆中对象的地址，而句柄池中的对象实例包含指向对象实例数据和类型数据的指针，采用句柄访问方式要获得完整的对象信息需要进行三次指针定位。

- 直接指针访问对象，Java虚拟机需要在堆中为对象分配额外的空间存储指向方法区对象类型数据的指针，采用直接指针访问方式，对象引用直接存储堆中对象的地址，只需要进行两次指针定位。目前hot spot就是采用这种对象访问方式

- 使用句柄访问的好处是在每次对象位置发生变动（如垃圾回收）时只需要改变句柄中指向实例数据的指针，而指向对象类型数据的指针和对象引用指针reference都不需要修改，而使用直接指针访问，当对象发生移动时对象引用reference需要修改。但是使用直接指针访问方式少了一次指针定位的时间开销速度更快。

## 四、GC垃圾回收

### 4.1、垃圾标记算法

- __引用计数法__
  - 给对象添加一个引用计数器，每被引用一次就+1，减少一次引用就-1。但是难以解决循环引用问题。

- __GC Rooting可达性分析法__
  - 通过一系列的 ‘GC Roots’ 的对象作为起始点，从这些节点出发所走过的路径称为引用链。当一个对象到 GC Roots 没有任何引用链相连的时候说明对象不可用。
  - __可作为 GC Roots 的对象：__
    1. 虚拟机栈(栈帧中的本地变量表)中引用的对象
    2. 本地方法栈中 JNI(即一般说的 Native 方法) 引用的对象
    3. 方法区中类静态属性引用的对象
    4. 方法区中常量引用的对象


### 4.2、java的四种引用
- __强引用__
  - 类似于 Object obj = new Object(); 创建的，只要强引用在就不回收。

- __软引用__
  - SoftReference 类实现软引用。在系统要发生内存溢出异常之前，将会把这些对象列进回收范围之中进行二次回收。

- __弱引用__
  - WeakReference 类实现弱引用。对象只能生存到下一次垃圾收集之前。在垃圾收集器工作时，无论内存是否足够都会回收掉只被弱引用关联的对象。

- __虚引用__
  - PhantomReference 类实现虚引用。无法通过虚引用获取一个对象的实例，为一个对象设置虚引用关联的唯一目的就是能在这个对象被收集器回收时收到一个系统通知。


### 4.3、垃圾回收算法
- __标记清除算法（Mark-Sweep）：__
  - 最基础的垃圾回收算法，分为两个阶段，标注和清除。标记阶段标记出所有需要回收的对象，清除阶段回收被标记的对象所占用的空间
  - 该算法最大的问题是内存碎片化严重，后续可能发生大对象不能找到可利用空间的问题

- __复制算法（copying）：__
  - 按内存容量将内存划分为等大小的两块。每次只使用其中一块，当这一块内存满后将尚存活的对象复制到另一块上去，把已使用的内存清掉
  - 算法虽然实现简单，内存效率高，不易产生碎片，但是最大的问题是可用内存被压缩到了原本的一半。且存活对象增多的话， Copying 算法的效率会大大降低

- __标记整理算法（Mark-Compact）__
  - 标记阶段和 Mark-Sweep 算法相同， 标记后不是清理对象，而是将存活对象移向内存的一端。然后清除端边界外的对象。
  - 避免了内存碎片化和被压缩为一半的问题，缺点是效率要比前两种低

- __分代收集算法__
  - 分代收集法是目前大部分 JVM 所采用的方法，其核心思想是根据对象存活的不同生命周期将内存划分为不同的域，一般情况下将 GC 堆划分为老生代(Tenured/Old Generation)和新生代(YoungGeneration)。老生代的特点是每次垃圾回收时只有少量对象需要被回收，新生代的特点是每次垃圾回收时都有大量垃圾需要被回收，因此可以根据不同区域选择不同的算法
  - 目前大部分 JVM 的 GC 对于新生代都采取 Copying 算法，因为新生代中每次垃圾回收都要回收大部分对象，即要复制的操作比较少，但通常并不是按照 1： 1 来划分新生代。一般将新生代划分为一块较大的 Eden 空间和两个较小的 Survivor 空间(From Space, To Space)，每次使用Eden 空间和其中的一块 Survivor 空间，当进行回收时，将该两块空间中还存活的对象复制到另一块 Survivor 空间中。
  - 而老年代因为每次只回收少量对象，因而采用 标记整理 算法

### 4.4、垃圾回收器

- __CMS回收器__
  - CMS (Concurrent Mark Sweep))收集器是一种年老代垃圾收集器配合parnew一起使用，以获取最短回收停顿时间为目标的收集器。和其他年老代使用标记-整理算法不同, 他基于__标记——清除__算法实现。
  - 最短的垃圾收集停顿时间可以为交互比较高的程序提高用户体验
  - CMS 收集器工作过程：
    1. 初始标记：只是标记一下 GC Roots 能直接关联的对象，速度很快，仍然需要暂停所有的工作线程。
    2. 并发标记：进行 GC Roots 跟踪的过程，和用户线程一起工作，不需要暂停工作线程。
    3. 重新标记：为了修正在并发标记期间，因用户程序继续运行而导致标记产生变动的那一部分对象的标记记录，仍然需要暂停所有的工作线程。
    4. 并发清除：清除 GC Roots 不可达对象，和用户线程一起工作，不需要暂停工作线程。由于耗时最长的并发标记和并发清除过程中，垃圾收集线程可以和用户现在一起并发工作， 所以总体上来看CMS 收集器的内存回收和用户线程是一起并发地执行。

- __G1垃圾回收器__
  - Garbage first 垃圾收集器是目前垃圾收集器理论发展的最前沿成果，相比与 CMS 收集器， G1 收集器两个最突出的改进是
  - 堆内存是一个被拆分成很多固定大小的内存区域。每个区域的大小是JVM启动时决定的。JVM通常会化成出2000个区域，每个区域大小是1 ~ 32Mb。
    ![](https://gitee.com/jingxuanye/yjx-pictures/raw/master/pic/20200526161844.png)
  - 活着的对象会被转移（复制/移动）到另一个或多个suvivor区域。如果年龄到了阈值，就会被分配到Old区域。
    ![](https://gitee.com/jingxuanye/yjx-pictures/raw/master/pic/20200526161925.png)

  - 总结一下，G1的Young GC的特点：
    - 堆被拆分成多个区域。
    - 新生代有一些并不连续的区域组成。这样可以很容易的扩容或收缩新生代的大小。
    - Young GC会Stop the World。
    - Young GC是多线程并行的。
    - 活着的对象会被复制移动到suvior或者old区域。

### 4.5、垃圾回收什么时候执行？
- __触发MinorGC(Young GC)__
  - 虚拟机在进行minorGC之前会判断老年代最大的可用连续空间是否大于新生代的所有对象总空间
    1、如果大于的话，直接执行minorGC
    2、如果小于，判断是否开启HandlerPromotionFailure，没有开启直接FullGC
    3、如果开启了HanlerPromotionFailure, JVM会判断老年代的最大连续内存空间是否大于历次晋升的大小，如果小于直接执行FullGC
    4、如果大于的话，执行minorGC

- __触发FullGC__
  - 老年代空间不足
    - 如果创建一个大对象，Eden区域当中放不下这个大对象，会直接保存在老年代当中，如果老年代空间也不足，就会触发Full GC。为了避免这种情况，最好就是不要创建太大的对象。

  - 持久代空间不足
    - 如果有持久代空间的话，系统当中需要加载的类，调用的方法很多，同时持久代当中没有足够的空间，就出触发一次Full GC

  - YGC出现promotion failure
    - promotion failure发生在Young GC, 如果Survivor区当中存活对象的年龄达到了设定值，会就将Survivor区当中的对象拷贝到老年代，如果老年代的空间不足，就会发生promotion failure， 接下去就会发生Full GC.

  - 统计YGC发生时晋升到老年代的平均总大小大于老年代的空闲空间
    - 在发生YGC是会判断，是否安全，这里的安全指的是，当前老年代空间可以容纳YGC晋升的对象的平均大小，如果不安全，就不会执行YGC,转而执行Full GC。

  - 显示调用System.gc

### 4.6、内存泄露
内存泄露就是指一个不再被程序使用的对象或变量一直被占据在内存中。java中的内存泄露的情况：
1. 长生命周期的对象bai持有短生命周期对象的引用就很可能发生内存泄露

2. 集合类，而如果集合类是全局性的变量（比如类中的静态属性，全局性的map等即有静态引用或final一直指向它），那么没有相应的删除机制，很可能导致集合所占用的内存只增不减

3. 单例模式。不正确使用单例模式是引起内存泄露的一个常见问题，单例对象在被初始化后将在JVM的整个生命周期中存在（以静态变量的方式），如果单例对象持有外部对象的引用，那么这个外部对象将不能被jvm正常回收

4. threadLocal内存泄露


### 4.7、内存溢出


## 五、JVM调优

### 5.1、内存区域大小分配
![](https://gitee.com/jingxuanye/yjx-pictures/raw/master/pic/20200602215931.png)

### 5.2、垃圾回收器设置
![](https://gitee.com/jingxuanye/yjx-pictures/raw/master/pic/20200602220008.png)

### 5.3、参数预估
![](https://gitee.com/jingxuanye/yjx-pictures/raw/master/pic/20200602220420.png)

![](https://gitee.com/jingxuanye/yjx-pictures/raw/master/pic/20200602220501.png)


### 5.4、JVM的OOM问题排查
![](https://gitee.com/jingxuanye/yjx-pictures/raw/master/pic/20200602221648.png)

![](https://gitee.com/jingxuanye/yjx-pictures/raw/master/pic/20200602221817.png)


## 六、JDK1.8改进

### 6.1、内存空间改进
- 原来的永久代存放了常量池和类信息，1.8之后把常量池放进了堆里，类信息放入了元空间中（metaspace）

## 参考文章
- [JVM性能调优实践——G1 垃圾收集器分析、调优篇](https://cloud.tencent.com/developer/article/1498990)
- [Java虚拟机（JVM）你只要看这一篇就够了！](https://www.cnblogs.com/aishangJava/p/9541920.html)
- [JVM——G1收集器](https://juejin.im/post/5bc6d4266fb9a05d151cd392)
- [jstat命令详解---JVM的统计监测工具](https://www.cnblogs.com/sxdcgaq8080/p/11089841.html)




