# 数据库进阶


- [数据库进阶](#%e6%95%b0%e6%8d%ae%e5%ba%93%e8%bf%9b%e9%98%b6)
  - [一、索引原理](#%e4%b8%80%e7%b4%a2%e5%bc%95%e5%8e%9f%e7%90%86)
    - [1.1、为什么使用索引？](#11%e4%b8%ba%e4%bb%80%e4%b9%88%e4%bd%bf%e7%94%a8%e7%b4%a2%e5%bc%95)
    - [1.2、索引类型](#12%e7%b4%a2%e5%bc%95%e7%b1%bb%e5%9e%8b)
    - [1.3、mysql的索引类型](#13mysql%e7%9a%84%e7%b4%a2%e5%bc%95%e7%b1%bb%e5%9e%8b)
    - [1.4、索引方法](#14%e7%b4%a2%e5%bc%95%e6%96%b9%e6%b3%95)
    - [1.5、InnoDB一棵B+树可以存放多少行数据？](#15innodb%e4%b8%80%e6%a3%b5b%e6%a0%91%e5%8f%af%e4%bb%a5%e5%ad%98%e6%94%be%e5%a4%9a%e5%b0%91%e8%a1%8c%e6%95%b0%e6%8d%ae)
  - [二、B树详解](#%e4%ba%8cb%e6%a0%91%e8%af%a6%e8%a7%a3)
    - [2.1、平衡多路查找树（B-Tree）](#21%e5%b9%b3%e8%a1%a1%e5%a4%9a%e8%b7%af%e6%9f%a5%e6%89%be%e6%a0%91b-tree)
    - [2.2、B+Tree](#22btree)
    - [2.3、b-tree和b+tree的比较](#23b-tree%e5%92%8cbtree%e7%9a%84%e6%af%94%e8%be%83)
  - [三、sql语句执行分析](#%e4%b8%89sql%e8%af%ad%e5%8f%a5%e6%89%a7%e8%a1%8c%e5%88%86%e6%9e%90)
    - [3.1、查询SQL执行记录](#31%e6%9f%a5%e8%af%a2sql%e6%89%a7%e8%a1%8c%e8%ae%b0%e5%bd%95)
    - [3.3、MySQL 语句执行时间](#33mysql-%e8%af%ad%e5%8f%a5%e6%89%a7%e8%a1%8c%e6%97%b6%e9%97%b4)
  - [四、事务](#%e5%9b%9b%e4%ba%8b%e5%8a%a1)
    - [4.1、什么是事务](#41%e4%bb%80%e4%b9%88%e6%98%af%e4%ba%8b%e5%8a%a1)
    - [4.2、事务的特性](#42%e4%ba%8b%e5%8a%a1%e7%9a%84%e7%89%b9%e6%80%a7)
    - [4.3、事务的隔离级别 & 对应的问题](#43%e4%ba%8b%e5%8a%a1%e7%9a%84%e9%9a%94%e7%a6%bb%e7%ba%a7%e5%88%ab--%e5%af%b9%e5%ba%94%e7%9a%84%e9%97%ae%e9%a2%98)
    - [4.4、MVCC机制](#44mvcc%e6%9c%ba%e5%88%b6)
  - [五、数据库的锁](#%e4%ba%94%e6%95%b0%e6%8d%ae%e5%ba%93%e7%9a%84%e9%94%81)
    - [3.5、数据库锁](#35%e6%95%b0%e6%8d%ae%e5%ba%93%e9%94%81)
  - [六、mysql的高可用方案](#%e5%85%admysql%e7%9a%84%e9%ab%98%e5%8f%af%e7%94%a8%e6%96%b9%e6%a1%88)
    - [5.1、读写分离](#51%e8%af%bb%e5%86%99%e5%88%86%e7%a6%bb)
    - [5.2、双写一致性问题](#52%e5%8f%8c%e5%86%99%e4%b8%80%e8%87%b4%e6%80%a7%e9%97%ae%e9%a2%98)
    - [七、mysql问题排查](#%e4%b8%83mysql%e9%97%ae%e9%a2%98%e6%8e%92%e6%9f%a5)
  - [参考文章](#%e5%8f%82%e8%80%83%e6%96%87%e7%ab%a0)

## 一、索引原理

### 1.1、为什么使用索引？
  - 索引可以把随机IO变成顺序IO
  - 索引能极大的减少存储引擎需要扫描的数据量
  - 索引可以帮助我们在进行分组、排序等操作时，避免使用临时表

### 1.2、索引类型

### 1.3、mysql的索引类型

InnoDB共有五种索引类型，基本都是基于b+tree

- primary——主键索引
- unique——主键索引
- key——普通索引
- fulltext——全文索引
- 组合索引

### 1.4、索引方法
- B-Tree，
- B+Tree，
- R-Tree,
- Hash，
- bitmap
- REVERSE
- 函数索引
- 倒排索引


### 1.5、InnoDB一棵B+树可以存放多少行数据？


- __mysql的最小存储单元__

  - 我们都知道计算机在存储数据的时候，有最小存储单元，这就好比我们今天进行现金的流通最小单位是一毛。在计算机中磁盘存储数据最小单元是扇区，一个扇区的大小是512字节，而文件系统（例如XFS/EXT4）他的最小单元是块，一个块的大小是4k而对于我们的InnoDB存储引擎也有自己的最小储存单元——页（Page），一个页的大小是16K。




- __一颗B+数的最大存储数量__

  - nnoDB存储引擎中默认每个页的大小为16KB，可通过参数innodb_page_size将页的大小设置为4K、8K、16K，在MySQL中可通过如下命令查看页的大小：
  ![](https://gitee.com/jingxuanye/yjx-pictures/raw/master/pic/20200519145257.png)

  - InnoDB存储引擎中页的大小为16KB，一般表的主键类型为INT（占用4个字节）或BIGINT（占用8个字节），指针类型也一般为4或8个字节，也就是说一个页（B+Tree中的一个节点）中大概存储16KB/(8B+8B)=1K个键值（因为是估值，为方便计算，这里的K取值为〖10〗^3）。

  - 也就是说一个深度为3的B+Tree索引可以维护10^3 * 10^3 * 10^3 = 10亿 条记录。

  - 实际情况中每个节点可能不能填充满，因此在数据库中，B+Tree的高度一般都在2~4层。


## 二、B树详解


### 2.1、平衡多路查找树（B-Tree）

- __一棵m阶的B-Tree有如下特性__

  1. 每个节点最多有m个孩子。
  2. 除了根节点和叶子节点外，其它每个节点至少有Ceil(m/2)个孩子。
  3. 若根节点不是叶子节点，则至少有2个孩子
  4. 所有叶子节点都在同一层，且不包含其它关键字信息
  5. 每个非终端节点包含n个关键字信息（P0,P1,…Pn, k1,…kn）
  6. 关键字的个数n满足：ceil(m/2)-1 <= n <= m-1
  7. ki(i=1,…n)为关键字，且关键字升序排序。
  8. Pi(i=1,…n)为指向子树根节点的指针。P(i-1)指向的子树的所有节点关键字均小于ki，但都大于k(i-1)

- __B-Tree的结构__
  B-Tree中的每个节点根据实际情况可以包含大量的关键字信息和分支，如下图所示为一个3阶的B-Tree：
  ![](https://gitee.com/jingxuanye/yjx-pictures/raw/master/pic/20200519145858.png)

  - 每个节点占用一个盘块的磁盘空间，一个节点上有两个升序排序的关键字和三个指向子树根节点的指针，指针存储的是子节点所在磁盘块的地址。两个关键词划分成的三个范围域对应三个指针指向的子树的数据的范围域。以根节点为例，关键字为17和35，P1指针指向的子树的数据范围为小于17，P2指针指向的子树的数据范围为17~35，P3指针指向的子树的数据范围为大于35。

  - 模拟查找关键字29的过程：

    1. 根据根节点找到磁盘块1，读入内存。【磁盘I/O操作第1次】
    2. 比较关键字29在区间（17,35），找到磁盘块1的指针P2。
    3. 根据P2指针找到磁盘块3，读入内存。【磁盘I/O操作第2次】
    4. 比较关键字29在区间（26,30），找到磁盘块3的指针P2。
    5. 根据P2指针找到磁盘块8，读入内存。【磁盘I/O操作第3次】
    6. 在磁盘块8中的关键字列表中找到关键字29。
  
  - 分析上面过程，发现需要3次磁盘I/O操作，和3次内存查找操作。由于内存中的关键字是一个有序表结构，可以利用二分法查找提高效率。而3次磁盘I/O操作是影响整个B-Tree查找效率的决定因素。B-Tree相对于AVLTree缩减了节点个数，使每次磁盘I/O取到内存的数据都发挥了作用，从而提高了查询效率。


### 2.2、B+Tree

- __为什么要升级B+Tree__

  - B+Tree是在B-Tree基础上的一种优化，使其更适合实现外存储索引结构，InnoDB存储引擎就是用B+Tree实现其索引结构。

  - 从上一节中的B-Tree结构图中可以看到每个节点中不仅包含数据的key值，还有data值。而每一个页的存储空间是有限的，如果data数据较大时将会导致每个节点（即一个页）能存储的key的数量很小，当存储的数据量很大时同样会导致B-Tree的深度较大，增大查询时的磁盘I/O次数，进而影响查询效率。

  - 在B+Tree中，所有数据记录节点都是按照键值大小顺序存放在同一层的叶子节点上，而非叶子节点上只存储key值信息，这样可以大大加大每个节点存储的key值数量，降低B+Tree的高度。

- __B+Tree的结构__

  - 由于B+Tree的非叶子节点只存储键值信息，假设每个磁盘块能存储4个键值及指针信息，则变成B+Tree后其结构如下图所示
  ![](https://gitee.com/jingxuanye/yjx-pictures/raw/master/pic/20200519150609.png)

  - 通常在B+Tree上有两个头指针，一个指向根节点，另一个指向关键字最小的叶子节点，而且所有叶子节点（即数据节点）之间是一种链式环结构。因此可以对B+Tree进行两种查找运算：
    1. 对于主键的范围查找和分页查找
    2. 从根节点开始，进行随机查找

  - mysql的InnoDB存储引擎在设计时是将根节点常驻内存的，也就是说查找某一键值的行记录时最多只需要1~3次磁盘I/O操作。

  - 数据库中的B+Tree索引可以分为聚集索引（clustered index）和辅助索引（secondary index）。上面的B+Tree示例图在数据库中的实现即为聚集索引，聚集索引的B+Tree中的叶子节点存放的是整张表的行记录数据。辅助索引与聚集索引的区别在于辅助索引的叶子节点并不包含行记录的全部数据，而是存储相应行数据的聚集索引键，即主键。当通过辅助索引来查询数据时，InnoDB存储引擎会遍历辅助索引找到主键，然后再通过主键在聚集索引中找到完整的行记录数据。


### 2.3、b-tree和b+tree的比较
  - __B树，它的特点是：__
      - 不再是二叉搜索，而是m叉搜索；
      - 叶子节点，非叶子节点，都存储数据；
      - 中序遍历，可以获得所有节点；
  - __B+树的特点是：__
    - 非叶子节点不再存储数据，数据只存储在同一层的叶子节点上；
    - 叶子之间，增加了链表，获取所有节点，不再需要中序遍历；
  - __以上改进让B+树比B树有更优的特性：__

    - 范围查找，定位min与max之后，中间叶子节点，就是结果集，不用中序回溯（范围查询在SQL中用得很多，这是B+树比B树最大的优势）；
    - 叶子节点存储实际记录行，记录行相对比较紧密的存储，适合大数据量磁盘存储；非叶子节点存储记录的PK，用于查询加速，适合内存存储；
    - 非叶子节点，不存储实际记录，而只存储记录的KEY的话，那么在相同内存的情况下，B+树能够存储更多索引；

## 三、sql语句执行分析

### 3.1、查询SQL执行记录

- __查询日志功能是否开启__

  ```sql
  show variables LIKE 'general%';
  ```
  - general_log:日志记录功能是否开启，默认为OFF
  - general_log_file:日志存放路径

- __开启日志功能__
    ```sql
  set GLOBAL general_log = 'ON';
  ```

- __在指定路径查看SQL记录__


### 3.2、explain 分析

大部分的性能分析都需要使用到该命令，可以用来查看SQL语句的执行效果，可以帮助选择更好地索引和优化语句。

- __使用方法__
  explain + SQL语句
  ```sql
  explain select * from table_name where column_one = '123'
  ```
- __参数解析__



### 3.3、MySQL 语句执行时间



## 四、事务

### 4.1、什么是事务
> 数据库操作的最小工作单元，是作为单个逻辑工作单元执行的一系列操作；事务是一组不可再分割的操作集合（工作逻辑单元）

> 事务最经典常用的栗子可能就是转账：一个账户少钱了，哪另一个账户肯定要多钱，李永龙说过，亏本的买卖咱可不干，吃亏了不高兴！所以，少钱和多钱这两个操作，要么同时成功，要么同时失败！

- __MySQL中如何开启事务？__
  - 手工开启：begin/start transaction
  - 事务提交或回滚：commit/rollback
  - 设定事务是否自动开启：set session autocommit = on/off

### 4.2、事务的特性

事务(TRANSACTION)是作为单个逻辑工作单元执行的一系列操作， 这些操作作为一个整体一起向系统提交，要么都执行、要么都不执行 。 事务是一个不可分割的工作逻辑单元事务必须具备以下四个属性，简称 ACID 属性：
  
- A（Atomicity）原子性
  - 最小的工作单元，要么一起成功，要么一起失败

- C（Consistency）一致性
  - 一致性也称作是完整性，就是说事务的执行不能破坏数据库的一致性，一个事务在执行后，数据库必须从一个状态转变为另一个状态

- I（Isolation）隔离性
  - 并发的事务相互隔离，互不干扰

- D（Durability）持久性
  - 持久性是指事务一旦提交，对数据库的状态就应该被永久保存




### 4.3、事务的隔离级别 & 对应的问题


- __事务隔离级别：__
    ANSI/ISO SQL标准定义了4中事务隔离级别：
    - __未提交读（read uncommitted）：__ Read Uncommitted是隔离级别最低的一种事务级别。在这种隔离级别下，已发生脏读（Dirty Read）
    - __提交读（read committed）：__ 在Read Committed隔离级别下，一个事务可能会遇到不可重复读（Non Repeatable Read）的问题
    - __重复读（repeatable read）：__ 在Repeatable Read隔离级别下，一个事务可能会遇到幻读（Phantom Read）的问题。
    - __串行读（serializable）：__ Serializable是最严格的隔离级别。在Serializable隔离级别下，所有事务按照次序依次执行，因此，脏读、不可重复读、幻读都不会出现。虽然Serializable隔离级别下的事务具有最高的安全性，但是，由于事务是串行执行，所以效率会大大下降，应用程序的性能会急剧降低。如果没有特别重要的情景，一般都不会使用Serializable隔离级别。
    - 不同的隔离级别有不同的现象，并有不同的锁定/并发机制，隔离级别越高，数据库的并发性就越差，4种事务隔离级别分别表现的现象如下表：

      |隔离级别         |脏读|不可重复读|幻读|
      |----------------|----|-------|------|
      |read uncommitted|允许|允许    |允许  |
      |read committed  |    |允许    |允许  |
      |repeatable read |    |        |允许 |
      |serializable    |    |        |     |

 - __事务隔离导致的问题__

    - __脏读（dirty read）__
      - Read Uncommitted是隔离级别最低的一种事务级别。在这种隔离级别下，一个事务会读到另一个事务更新后但未提交的数据，如果另一个事务回滚，那么当前事务读到的数据就是脏数据，这就是脏读（Dirty Read）。
      - __简单来说就是读到别的事务没有提交的数据。__


    - __不可重复读（nonrepeatable read）__
      - 在Read Committed隔离级别下，一个事务可能会遇到不可重复读（Non Repeatable Read）的问题。不可重复读是指，两个相同的查询返回了不同的结果，在这个事务还没有结束时，如果另一个事务恰好修改了这个数据，那么，在第一个事务中，两次读取的数据就可能不一致。
      - __简单来说先前读取的数据，被别的事务改变了，再读就跟原来不一样了。__

    - __幻读（phantom read）__
      - MySql默认的隔离级别为Repeatable Read（重复读），因此只会出现幻读的情况。幻读是指，在一个事务中，第一次查询某条记录，发现没有，但是，当试图更新这条不存在的记录时，竟然能成功（或者插入该记录出现主键冲突），并且，再次读取同一条记录，它就神奇地出现了。
      - 简单来说就是第一次读的时候发现什么都没有，另一个事务偷偷放了东西进去，再去访问的时候惊讶地居然发现有东西了

    - __幻读和不可重复读的区别：__
      - 幻读中事务二的数据操作仅仅是插入和删除，读取的记录数量前后不一致。而不可重复读中是修改数据，导致同一个查询返回了不同的结果


- __如何解决幻读__

  1. 设置事务隔离级别为串行读（效率低下，太low）
  2. 使用间隙锁
  3. InnoDB的MVCC机制来解决



### 4.4、MVCC机制
我们都知道，在事务隔离级别设置为 __可重复读__ 的时候，会导致 __幻读__ 的问题发生。而innodb引擎的可重复读事务机制却不存在幻读的问题，因为innodb利用锁机制和MVCC避免了这个问题

  - __什么是MVCC__
    > MVCC，Multi-Version Concurrency Control，多版本并发控制。MVCC 是一种并发控制的方法，一般在数据库管理系统中，实现对数据库的并发访问；在编程语言中实现事务内存。
  - __MVCC原理__
    - MVCC 使每个连接到数据库的读者，在某个瞬间看到的是数据库的一个快照，写者写操作造成的变化在写操作完成之前（或者数据库事务提交之前）对于其他的读者来说是不可见的。

## 五、数据库的锁

### 3.5、数据库锁

- __行级锁：__
  - 行级锁是一种排他锁，防止其他事务修改此行；在使用以下语句时， Oracle 会自动应用行级锁：
    1. INSERT、 UPDATE、 DELETE、 SELECT … FOR UPDATE [OF columns] [WAIT n | NOWAIT];
    2. SELECT … FOR UPDATE 语句允许用户一次锁定多条记录进行更新
    3. 使用 COMMIT 或 ROLLBACK 语句释放锁
  - MySQL 的行锁是在引擎层由各个引擎自己实现的。MyISAM 引擎就不支持行锁。不支持行锁意味着并发控制只能使用表锁，对于这种引擎的表，同一张表上任何时刻只能有一个更新在执行，这就会影响到业务并发度。InnoDB 是支持行锁的，这也是 MyISAM 被 InnoDB 替代的重要原因之一。
  - 在 InnoDB 事务中，行锁是在需要的时候才加上的，但并不是不需要了就立刻释放，而是要等到事务结束时才释放。这个就是两阶段锁协议。知道了这个设定，对我们使用事务有什么帮助呢？那就是，如果你的事务中需要锁多个行，要把最可能造成锁冲突、最可能影响并发度的锁尽量往后放。
  - 由于mysql 的行锁是针对索引加的锁，不是针对记录加的锁，所以虽然是访问不同行的记录，但如果是使用相同的索引键，是会出现锁冲突的
    - a. 使用相同索引键值的冲突
    - b. 使用不同索引键值但是同一行的冲突
    - c. 创建了索引，但使用的是表锁

  - __InnoDB三种行锁__
    - Record Lock（行锁）：单个行记录上的范围
      - Record Lock总是会锁住索引记录，如果InnoDB存储引擎建立的时候没有设置任何一个索引，这时InnoDB存储引擎会使用隐式的主键来进行锁定。
      - 行锁锁定的是索引记录，而不是行数据，也就是说锁定的是key。
    - Gap Lock（间隙锁）：锁定一个范围，但不包含记录本身
      - Gap Lock在InnoDB的唯一作用就是防止其他事务的插入操作，以此防止幻读的发生。
    - Next-Key Lock（后码锁）：锁定一个范围，并且锁定记录本身 Gap Lock + Record Lock

- __表级锁：__
  - 表示对当前操作的整张表加锁，它实现简单，资源消耗较少，被大部分 MySQL 引擎支持。最常使用的 MYISAM 与 INNODB 都支持表级锁定。表级锁定分为 __表共享读锁（共享锁）__ 与 __表排他写锁（排它锁）__
  - MyISAM在执行查询语句（SELECT）前，会自动给涉及的所有表加读锁，在执行更新操作（UPDATE、DELETE、INSERT等）前，会自动给涉及的表加写锁。
  - 表的读操作，不会阻塞其他用户对同一表的读请求，但会阻塞对同一表的写请求；写操作，则会阻塞其他用户对同一表的读和写操作
  - MyISAM存储引擎的表级锁中读锁和写锁是互斥的，读写操作是串行的。__那么，一个进程请求某个 MyISAM表的读锁，同时另一个进程也请求同一表的写锁，写进程先获得锁__。不仅如此，即使读请求先到锁等待队列，写请求后到，写锁也会插到读锁请求之前！这是因为MySQL认为写请求一般比读请求要重要。这也正是MyISAM表不太适合于有大量更新操作和查询操作应用的原因，因为，大量的更新操作会造成查询操作很难获得读锁，从而可能永远阻塞。
    - 通过指定启动参数low-priority-updates，使MyISAM引擎默认给予读请求以优先的权利。
    - 通过执行命令SET LOW_PRIORITY_UPDATES=1，使该连接发出的更新请求优先级降低
    - 通过指定INSERT、UPDATE、DELETE语句的LOW_PRIORITY属性，降低该语句的优先级
    - MySQL也提供了一种折中的办法来调节读写冲突，即给系统参数max_write_lock_count设置一个合适的值，当一个表的读锁达到这个值后，MySQL就暂时将写请求的优先级降低，给读进程一定获得锁的机会

- __页级锁：__
  - 页级锁是 MySQL 中锁定粒度介于行级锁和表级锁中间的一种锁。表级锁速度快，但冲突多，行级冲突少，但速度慢。所以取了折衷的页级，一次锁定相邻的一组记录。 BDB 支持页级锁

- __死锁：__
  - MyISAM表锁是deadlock free的，这是因为MyISAM总是一次获得所需的全部锁，要么全部满足，要么等待，因此不会出现死锁。但在InnoDB中，除单个SQL组成的事务外，锁是逐步获得的，当两个事务都需要获得对方持有的排他锁才能继续完成事务，这种循环锁等待就是典型的死锁。
  - 当并发系统中不同线程出现循环资源依赖，涉及的线程都在等待别的线程释放资源时，就会导致这几个线程都进入无限等待的状态，称为死锁。
  ![](https://gitee.com/jingxuanye/yjx-pictures/raw/master/pic/20200426113818.png)
  
  - 事务 A 在等待事务 B 释放 id=2 的行锁，而事务 B 在等待事务 A 释放 id=1 的行锁。 事务 A 和事务 B 在互相等待对方的资源释放，就是进入了死锁状态。
  
  - 当出现死锁以后，有两种策略：
    1. 直接进入等待，直到超时。这个超时时间可以通过参数 innodb_lock_wait_timeout 来设置。
    2. 发起死锁检测，发现死锁后，主动回滚死锁链条中的某一个事务，让其他事务得以继续执行。将参数 innodb_deadlock_detect 设置为 on，表示开启这个逻辑。减少死锁的主要方向，就是控制访问相同资源的并发事务量。


## 六、mysql的高可用方案


### 5.1、读写分离

- __如何实现mysql的读写分离？__
  - 就是基于主从复制架构，简单来说，就搞一个主库，挂多个从库，然后我们就单单只是写主库，然后主库会自动把数据给同步到从库上去。

- __MySQL主从复制原理的是啥？__
  1. 主库将变更写binlog日志，然后从库连接到主库之后，从库有一个IO线程，将主库的binlog日志拷贝到自己本地，写入一个中继日志中。  
  2. 着从库中有一个SQL线程会从中继日志读取binlog，然后执行binlog日志中的内容，也就是在自己本地再次执行一遍SQL，这样就可以保证自己跟主库的数据是一样的。

- __主从复制的关键点__
  - 这里有一个非常重要的一点，就是从库同步主库数据的过程是串行化的，也就是说主库上并行的操作，在从库上会串行执行
  - 由于从库从主库拷贝日志以及串行执行SQL的特点，在高并发场景下，从库的数据一定会比主库慢一些，是有延时的。
  - 所以经常出现，刚写入主库的数据可能是读不到的，要过几十毫秒，甚至几百毫秒才能读取到。
  - 而且这里还有另外一个问题，就是如果主库突然宕机，然后恰好数据还没同步到从库，那么有些数据可能在从库上是没有的，有些数据可能就丢失了

- __主从复制数据丢失问题方案__
  - 如果主库突然宕机，然后恰好数据还没同步到从库，那么有些数据可能在从库上是没有的，有些数据可能就丢失了
  - 我们可以采用半同步复制即semi-sync复制来解决。
  - 指的就是主库写入binlog日志之后，就会将强制此时立即将数据同步到从库，从库将日志写入自己本地的relay log之后，接着会返回一个ack给主库，主库接收到至少一个从库的ack之后才会认为写操作完成了。


- __主从复制延时问题方案__
  - 产生所谓的主从延迟主要是看主库的写并发。主库的写并发达到1000QPS，从库的延时有几ms，主库的写并发达到2000QPS，从库的延时可能有几十ms
  - 一般我们可以采用并行复制的方案来解决。从库开启多个线程，并行读取relay log中不同库的日志，然后并行重放不同库的日志，这是库级别的并行。
  - 采用分库的方案，将一个主库拆分为4个主库，每个主库的写并发就500/s，此时主从延迟可以忽略不计


### 5.2、双写一致性问题



### 七、mysql问题排查



## 参考文章  
  - [开发人心里都该有的那颗 B 树](https://cloud.tencent.com/developer/article/1497410)  
  - [为什么 MySQL 索引要使用 B+树而不是其它树形结构？比如 B 树？](https://juejin.im/post/5d519d576fb9a06b2116dce4)
  - [mysql语句执行分析](https://cloud.tencent.com/developer/article/1498250)
  - [五分钟搞清楚 MVCC 机制](https://cloud.tencent.com/developer/article/1497291)
  - [五分钟搞清楚MySQL事务隔离级别](https://mp.weixin.qq.com/s?__biz=MzI1Mzg4OTMxNQ==&mid=2247484138&idx=1&sn=77f222160f8f26cbb868eb7a4547e7f1&chksm=e9ccdca6debb55b0e7e565aa2b69ca6b05e5f965f84a0317fa6c26191a229c00aa03f1757228&scene=21#wechat_redirect)
  - [MySQL锁(表锁,行锁,共享锁,排它锁,间隙锁)使用详解](https://www.cnblogs.com/drizzle-xu/p/10435638.html)
  - [mysql占用CPU超过100%解决过程](https://blog.csdn.net/jimshen/article/details/78706538)
  - [mysql InnoDB引擎的行锁和表锁](https://blog.csdn.net/qq_23473123/article/details/80069708)
  - [mysql锁——innodb的行级锁](https://www.cnblogs.com/huangfuyuan/p/9510022.html)
  - [MySQL锁(表锁,行锁,共享锁,排它锁,间隙锁)使用详解](https://www.cnblogs.com/drizzle-xu/p/10435638.html)