# 多线程进阶


## 一、多线程基础

### 1.1、多线程内存模型简介
![](https://gitee.com/jingxuanye/yjx-pictures/raw/master/pic/20200526163314.png)

### 1.2、指令重排

- 指令重排是指JVM在编译Java代码的时候，或者CPU在执行JVM字节码的时候，对现有的指令顺序进行重新排序。
- 指令重排的目的是为了在不改变程序执行结果的前提下，优化程序的运行效率。需要注意的是，这里所说的不改变执行结果，指的是不改变单线程下的程序执行结果。
- 指令重排是一把双刃剑，虽然优化了程序的执行效率，但是在某些情况下，会影响到多线程的执行结果。

### 1.3、内存屏障


## 二、线程状态

### 2.1、线程的运行状态
  ![](https://gitee.com/jingxuanye/yjx-pictures/raw/master/pic/20200509171056.png)
  
  - __new__ :
    - 创建后尚未启动的线程。


  - __runnable__ 
    - 就绪状态，可运行状态，调用了线程的start方法，已经在java虚拟机中执行，等待获取操作系统资源如CPU，操作系统调度运行。 这个状态下发生的等待一般是其他系统资源, 而不是锁, Sleep等


  - __blocked__ 
    - 阻塞状态下, 是在多个线程有同步操作的场景, 比如正在等待另一个线程的synchronized 块的执行释放, 或者可重入的 synchronized块里别人调用wait() 方法, 也就是这里是线程在等待进入临界区
  
  - __waiting__  
    - 出于这种状态的线程不会被 CPU 分配时间，它们要等其他线程显示的唤醒。
    - 进入wait状态的条件
      - 没有设置 Timeout 参数的 Object.wait() 方法。
      - 没有设置 Timeout 参数的 Thread.join() 方法。
      - LookSupport.park() 方法。

  
  - __timed_waiting__  这
    - 个状态就是有限的(时间限制)的WAITING, 一般出现在调用wait(long), join(long)等情况下, 另外一个线程sleep后, 也会进入TIMED_WAITING状态
    - sleep时间到了后线程自动唤醒
    - wait和join时间到了后线程抛出异常。
  
  - __terminated__ 
    - 这个状态下表示 该线程的run方法已经执行完毕了, 基本上就等于死亡了(当时如果线程被持久持有, 可能不会被回收)



### 2.2、wait和sleep的区别
  - 对于sleep()方法，我们首先要知道该方法是属于Thread类中的。而wait()方法，则是属于Object类中的。
  - sleep()方法的过程中，线程进入TIMED_WAITING时间，并不会释放锁，在设定时间到或被interrupt后抛出InterruptedException后进入RUNNABLE状态。而当调用wait()方法的时候，线程会放弃对象锁，进入waiting状态，只有针对此对象调用notify()方法后本线程才进入blocked状态，拿到锁内进入runnable状态
  - wait，notify和notifyAll只能在同步控制方法或者同步控制块里面使用，而sleep可以在任何地方使用
  - sleep必须捕获异常，而wait，notify和notifyAll不需要捕获异常。

### 2.3、start和run的区别
  - 线程的任务处理逻辑可以在Tread类的run实例方法中直接实现或通过该方法进行调用，因此run()相当于线程的任务处理逻辑的入口方法，它由Java虚拟机在运行相应线程时直接调用，而不是由应用代码进行调用。
  - 而start()的作用是启动相应的线程。启动一个线程实际是请求Java虚拟机运行相应的线程，而这个线程何时能够运行是由线程调度器决定的。start()调用结束并不表示相应线程已经开始运行，这个线程可能稍后运行，也可能永远也不会运行。


## 三、线程池

### 3.1、线程池的优点
  - 第一：降低资源消耗。通过重复利用已创建的线程降低线程创建和销毁造成的消耗。
  - 第二：提高响应速度。当任务到达时，任务可以不需要等到线程创建就能立即执行。
  - 第三：提高线程的可管理性。线程是稀缺资源，如果无限制地创建，不仅会消耗系统资源，还会降低系统的稳定性，使用线程池可以进行统一分配、调优和监控。但是，要做到合理利用线程池，必须对其实现原理了如指掌

### 3.2、线程池创建
- __ThreadPoolExecutor构造方法详解：__
  |参数名 |作用|
  |:--:|:--:|
  |corePoolSize   |核心线程池大小|
  |maximumPoolSize|最大线程池大小|
  |keepAliveTime  |线程池中超过corePoolSize数目的空闲线程最大存活时间|
  |TimeUnit       |keepAliveTime时间单位|
  |workQueue      |阻塞任务队列|

- __构造函数__
  - __newSingleExecutor__
    ```java
    public static ExecutorService newSingleThreadExecutor() {
        return new FinalizableDelegatedExecutorService
            (new ThreadPoolExecutor(1, 1,
                                    0L, TimeUnit.MILLISECONDS,
                                    new LinkedBlockingQueue<Runnable>()));
    }
    ```
    - 因为LinkedBlockingQueue是长度为Integer.MAX_VALUE的队列，可以认为是无界队列，因此往队列中可以插入无限多的任务，在资源有限的时候容易引起OOM异常，同时因为无界队列，maximumPoolSize和keepAliveTime参数将无效，压根就不会创建非核心线程

  - __newFixedThreadPool__
    ```java
    public static ExecutorService newFixedThreadPool(int nThreads) {
        return new ThreadPoolExecutor(nThreads, nThreads,
                                      0L, TimeUnit.MILLISECONDS,
                                      new LinkedBlockingQueue<Runnable>());
    }

    ```
    - 允许的请求队列长度为Integer.MAX_VALUE，可能会堆积大量的请求，从而引起OOM异常


  - __newCachedThreadPool__
    ```java
    public static ExecutorService newCachedThreadPool() {
        return new ThreadPoolExecutor(0, Integer.MAX_VALUE,
                                      60L, TimeUnit.SECONDS,
                                      new SynchronousQueue<Runnable>());
    }
    ```
    - 当一个任务提交时，corePoolSize为0不创建核心线程，SynchronousQueue是一个不存储元素的队列，可以理解为队里永远是满的，因此最终会创建非核心线程来执行任务。
  
    - 对于非核心线程空闲60s时将被回收。因为Integer.MAX_VALUE非常大，可以认为是可以无限创建线程的，在资源有限的情况下容易引起OOM异常
  
  - __总结__
    - FixedThreadPool和SingleThreadExecutor => 允许的请求队列长度为Integer.MAX_VALUE，可能会堆积大量的请求，从而引起OOM异常
  
    - CachedThreadPool => 允许创建的线程数为Integer.MAX_VALUE，可能会创建大量的线程，从而引起OOM异常

### 3.3、工作流程

- __线程工作流程__

  ![](https://gitee.com/jingxuanye/yjx-pictures/raw/master/pic/线程池.jpg)

  1. 判断线程池里的核心线程是否都在执行任务，如果不是（核心线程空闲或者还有核心线程没有被创建）则创建一个新的工作线程来执行任务。如果核心线程都在执行任务，则进入下个流程。

  2. 线程池判断工作队列是否已满，如果工作队列没有满，则将新提交的任务存储在这个工作队列里。如果工作队列满了，则进入下个流程。

  3. 判断线程池里的线程是否都处于工作状态，如果没有，则创建一个新的工作线程来执行任务。如果已经满了，则交给饱和策略来处理这个任务。

  - __线程池初始化时，核心线程数量为0__

- __RejectedExecutionHandler：饱和策略__
  - 1、AbortPolicy（默认策略）：直接抛出异常
  - 2、CallerRunsPolicy：调用所在的主线程运行任务
  - 3、DiscardOldestPolicy：丢弃队列里最近的一个任务，并执行当前任务。
  - 4、DiscardPolicy：不处理，丢弃掉。




## 四、锁 && 线程安全

### 4.1、java中的各种锁

- __乐观锁__
    - 乐观锁是一种乐观思想，即认为读多写少，遇到并发写的可能性低，每次去拿数据的时候都认为别人不会修改，所以不会上锁，但是在更新的时候会判断一下在此期间别人有没有去更新这个数据，采取在写时先读出当前版本号，然后加锁操作（比较跟上一次的版本号，如果一样则更新），如果失败则要重复读-比较-写的操作
    - __CAS:CAS是英文单词Compare And Swap的缩写，翻译过来就是比较并替换__。
  
- __悲观锁__
  - 悲观锁是就是悲观思想，即认为写多，遇到并发写的可能性高，每次去拿数据的时候都认为别人会修改，所以每次在读写数据的时候都会上锁，这样别人想读写这个数据就会 block 直到拿到锁。java中的悲观锁就是 Synchronized,
  - __AQS  (AbstractQueuedSynchronizer 抽象队列同步器)  AQS框架下的锁则是先尝试 cas乐观锁去获取锁，获取不到，才会转换为悲观锁，如RetreenLock__

- __自旋锁__
  - 自旋锁原理非常简单， 如果持有锁的线程能在很短时间内释放锁资源，那么那些等待竞争锁的线程就不需要做内核态和用户态之间的切换进入阻塞挂起状态，它们只需要等一等（自旋），等持有锁的线程释放锁后即可立即获取锁，这样就避免用户线程和内核的切换的消耗。

- __可重入锁__
  - 当一个线程拥有锁的时候，下次可以直接不用获得锁，直接执行。

- __公平锁__
  - 线程竞争锁的时候进入一个队列里，先进先出，先来的先获取锁


### 4.2、synchronize同步锁

- synchronize是java中的一个关键字，它可以对方法、代码块进行加锁操作
  - 同步普通方法，锁的是当前对象。
  - 同步静态方法，锁的是当前 Class 对象。
  - 同步代码块，锁的是 {} 中的对象。
- synchronized的原理
  - JVM 是通过进入、退出对象监视器( Monitor )来实现对方法、同步块的同步的。

  - 具体实现是在编译之后在同步方法调用前加入一个 monitor.enter 指令，在退出方法和异常处插入 monitor.exit 的指令。

  - 其本质就是对一个对象监视器( Monitor )进行获取，而这个获取过程具有排他性从而达到了同一时刻只能一个线程访问的目的。

  - 而对于没有获取到锁的线程将会阻塞到方法入口处，直到获取锁的线程 monitor.exit 之后才能尝试继续获取锁。



### 4.3、ReentantLock

- ReentantLock 继承接口 Lock 并实现了接口中定义的方法， 他是一种可重入锁， 除了能完成 synchronized 所能完成的所有工作外，还提供了诸如可响应中断锁、可轮询锁请求、定时锁等避免多线程死锁的方法。



### 4.4、threadlocal

- __原理__
  - 每个线程Thread对象都包含一个成员变亮，threadlocalMap，threadlocald的put，get方法实际操作的是线程独有的threadlocalMap变量
  - threadLocalMap将当前线程对象t作为key，要存储的对象作为value存到map里面去。如果该Map不存在，则初始化一个。

- __内存泄露问题__
  ![](https://gitee.com/jingxuanye/yjx-pictures/raw/master/pic/20200522181031.png)
  - 通过源码知道threadLocalMap是threadlocal的一个静态内部类，主要用entry存储数据，而entry还是弱引用
    ![](https://gitee.com/jingxuanye/yjx-pictures/raw/master/pic/20200522181629.png)
  - 为什么entry是弱引用呢，主要为了解决内存泄露问题。假如entry是强引用，当threadlocal的值在运行结束后被设置为null，但是threadlocalmap中还保存这threadlocal的强引用，导致threadlocal无法被回收。产生内存泄露，而当是虚引用的时候，则完全可以回收掉threadlocal。
  - 但是当threadlocal作为map的key被回收后，value却无法被回收，所以我们最好用完threadlocal后手动remove掉key（jdk在每次put和get的时候都回去remove key）。


### 4.5、volatile

- __一个变量被定义为 volatile 的特性：__
    1. 保证此变量对所有线程的可见性
       - 每个线程操作数据的时候会把数据从主内存读取到自己的工作内存，如果他操作了数据并且写了，其他已经读取的线程的变量副本就会失效了，需要都数据进行操作又要再次去主内存中读取了。

    2. 禁止指令重排序优化。
       - 通过插入内存屏障保证一致性。volatile写是在前面和后面分别插入内存屏障，而volatile读操作是在后面插入两个内存屏障。

- __MESI（缓存一致性协议）__
  - 当CPU写数据时，如果发现操作的变量是共享变量，即在其他CPU中也存在该变量的副本，会发出信号通知其他CPU将该变量的缓存行置为无效状态，因此当其他CPU需要读取这个变量时，发现自己缓存中缓存该变量的缓存行是无效的，那么它就会从内存重新读取。


- __DCL(double check lock)问题__

- __volatile应用场景__


## 参考文章