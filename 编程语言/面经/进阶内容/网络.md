# 网络

- [网络](#网络)
  - [一、网络模型](#一网络模型)
    - [1.1、七层网络模型](#11七层网络模型)
    - [1.2、四层网络模型](#12四层网络模型)
    - [1.3、三次握手、四次挥手](#13三次握手四次挥手)
    - [1.4、 黏包问题](#14-黏包问题)
    - [1.5、 零拷贝问题](#15-零拷贝问题)
    - [1.6、TCP的11种状态](#16tcp的11种状态)
  - [二、http、https协议](#二httphttps协议)
    - [2.1、什么是HTTP?](#21什么是http)
    - [2.2、http协议发展史](#22http协议发展史)
    - [2.3、http2的多路复用](#23http2的多路复用)
    - [2.4、http缓存](#24http缓存)
    - [2.5、http报文](#25http报文)
    - [2.6、http的状态码有哪些](#26http的状态码有哪些)
    - [2.7、https](#27https)
    - [2.8、https的握手过程](#28https的握手过程)
    - [2.9、HTTPS 握手过程中，客户端如何验证证书的合法性](#29https-握手过程中客户端如何验证证书的合法性)
    - [2.10、https的对称加密和非对称加密](#210https的对称加密和非对称加密)
    - [2.11、https的安全性](#211https的安全性)
    - [2.12、HTTP方法具体作用](#212http方法具体作用)
    - [2.13、GET和POST有什么区别？](#213get和post有什么区别)
    - [2.14、PUT和POST有什么区别？](#214put和post有什么区别)
    - [2.15、HTTP的keep-alive是干什么的？](#215http的keep-alive是干什么的)
    - [2.16、tcp、udp区别](#216tcpudp区别)
  - [三、网络相关排查应用](#三网络相关排查应用)
    - [3.1、排查服务器有多少tcp连接](#31排查服务器有多少tcp连接)
  - [参考文章](#参考文章)

## 一、网络模型

### 1.1、七层网络模型

- 物理层
  - 网线、海底电缆等让电脑之间可以连接起来，传输0/1的电路信号


### 1.2、四层网络模型
根据七层网络模型简化为四层IP/TCP网络模型

- 数据链路层
  - 把0/1的电路信号进行分组描述。一组信号是一个数据包，叫一个帧，帧又分为标头和数据，标头包含一些说明性的东西，比如发送者，接收者，数据类型
  - 以太网协议规定，接入网络里的所有设备必须有一个网卡，网卡地址就是所谓的mac地址，每块网卡出厂时就有一个唯一的mac地址，48位的二进制，
  ![](https://gitee.com/jingxuanye/yjx-pictures/raw/master/pic/20200604213606.png)

- 网络层
  ![](https://gitee.com/jingxuanye/yjx-pictures/raw/master/pic/20200604214023.png)
  ![](https://gitee.com/jingxuanye/yjx-pictures/raw/master/pic/20200604214745.png)

- 传输层
  - 网络层是基于ip协议，进行主机和主机间寻址通信的，传输层其实是建立在主机的端口上，是通过socket来实现的，
  - udp和tcp都是传输层的协议，
  ![](https://gitee.com/jingxuanye/yjx-pictures/raw/master/pic/20200604220010.png)

- 应用层
  - 应用层就是对tcp/udp进行解析，处理，常见的有http/ftp协议


### 1.3、三次握手、四次挥手
- __三次握手__
  ```
  握手过程:
      发送端 -> 接收端  你听得到吗？
      接收端 -> 发送端  我听到的到，你听的到我吗？
      发送端 -> 接收端  我听的到，我们开始说话吧
  具体过程
      发送端发送当前seq（发送端序号）x 发送给当前接收端（发送SYN表识数据包）
      接收端返回ack（确认序号）x+1,seq(接收端序号) y 给发送端（发送SYN表识数据包）
      发送单发送ack（确认序号）y+1给接收端（发送ACK表识数据包）
  ```
- 为什么要三次握手
  - 如果不确认一次，那么我们发送如果网络不好那么服务端一直开着一个链接，客户端过了一会又发了一个信息，那么服务器端认为是一个新端请求就会创建一个新的链接，造成了不必要的性能的开销，三次握手就表示双方都收到，就不会出现上面的问题了


- __四次挥手__
  ```
  分手过程
      客户端 -> 服务器 请求关闭链接
      服务器 -> 客户端 确认到关闭
      服务器 -> 客户端 我要关闭了，你确认一下
      客户端 -> 服务端 我关闭了，你也关闭吧，不用回复了 
  具体过程
      客户端发送seq x+2（序号）ACK y+1 （确认序号）给服务端（FIN包）
      服务器发送ACK（确认序号）x+1（ACK包）
      服务器发送seq y+1 （序号）（FIN包）
      客户端发送ACK（确认序号）y+2
  ```


- 为什么要四次挥手
  - 由于我们的tcp是双向的，我们客户端发送给服务端说可以断开链接了，但是可能我们的服务端端数据还没有发送完成，所以需要进行一次确认，我们服务端发送一个ACK确认包给客户端，（我收到了），然后服务端再发送一个FIN包（我已经传输完毕了），可以断开链接了，然后客户端确认到关闭端请求，给服务端发送收到端消息，双方就关闭了。


### 1.4、 黏包问题

- __什么是黏包？__
  - TCP粘包是指发送方发送的若干包数据到接收方接收时粘成一包，从接收缓冲区看，后一包数据的头紧接着前一包数据的尾。

  - 出现粘包现象的原因是多方面的，它既可能由发送方造成，也可能由接收方造成。

  - TCP和UDP分别是面向连接和非面向连接的。因此TCP的socket编程，收发两端（客户端和服务器端）都要有成对的socket，因此，发送端为了将多个发往接收端的包，更有效的发到对方，使用了优化方法（Nagle算法），将多次间隔较小、数据量小的数据，合并成一个大的数据块，然后进行封包。这样，接收端，就难于分辨出来了，必须提供科学的拆包机制。

  - 对于UDP，不会使用块的合并优化算法，这样，实际上目前认为，是由于UDP支持的是一对多的模式，所以接收端的skbuff(套接字缓冲区）采用了链式结构来记录每一个到达的UDP包，在每个UDP包中就有了消息头（消息来源地址，端口等信息），这样，对于接收端来说，就容易进行区分处理了。所以UDP不会出现粘包问题。

- __如何解决黏包？__
  - 对于发送方引起的粘包现象，用户可通过编程设置来避免，TCP提供了强制数据立即传送的操作指令push，TCP软件收到该操作指令后，就立即将本段数据发送出去，而不必等待发送缓冲区满；
  - 对于接收方引起的粘包，则可通过优化程序设计、精简接收进程工作量、提高接收进程优先级等措施，使其及时接收数据，从而尽量避免出现粘包现象；
  - 由接收方控制，将一包数据按结构字段，人为控制分多次接收，然后合并，通过这种手段来避免粘包。

- __合理解决黏包方案-分包算法__
  - 分包算法分别采取了相应的解决办法。其基本思路是首先将待处理的接收数据流（长度设为m）强行转换成预定的结构数据形式，并从中取出结构数据长度字段，即图5中的n，而后根据n计算得到第一包数据长度
    ```
    1)若n<m，则表明数据流包含多包数据，从其头部截取n个字节存入临时缓冲区，剩余部分数据依此继续循环处理，直至结束。

    2)若n=m，则表明数据流内容恰好是一完整结构数据，直接将其存入临时缓冲区即可。

    3)若n>m，则表明数据流内容尚不够构成一完整结构数据，需留待与下一包数据合并后再行处理。
    ```

### 1.5、 零拷贝问题
- 一般文件传输过程
  - 考虑这样一种常用的情形：开发者需要将静态内容（类似图片、数据表、文件）展示给远程的用户。那么这个情形就意味着开发者需要先将静态内容从磁盘中拷贝出来放到一个内存buf中，然后将这个buf通过 socket！传输给用户，进而用户或者静态内容的展示。这看起来再正常不过了，但是实际上这是很低效的流程，我们把上面的这种情形抽象成下面的过程。
    ```java
    read(file, tmp buf, len);
    write( socket, tmp buf, len);
    ```
  ![](https://gitee.com/jingxuanye/yjx-pictures/raw/master/pic/20200628153719.png)

  - 先调用read将静态内容，这里假设为数据文件A，读取到 tmp buf。然后调用wrte将tmp入到 socket中
    ```java
    在这个过程中数据文件A的经历了4次复制的过程
    首先，调用read时，数据文件A拷贝到了 kernel模式；之后，CPU控制将 kernel模式数据复制到user模式下
    调用rite时，先将user模式下的内容复制到到 kernel模式下的 socke的 buffer中最后将 kernel模式下的 socket buffer的数据复制到网卡设备中传送
    ```

  - 从上面的过程可以看出，数据白白从 kernel模式到use「模式走了一圏，浪费了2次opy（第一次，从 kernel模式拷贝到user模式；第二次从user模式再拷贝回 kernel模式，即上面4次过程的第2和3步骤）。而且上面的过程中 kernel和user模式的上下文的切换也是4次。

- 零拷贝
  - 开发者可以用“零拷贝”技术来去掉这些无谓的复制。应用程序用Zero-Copy来请求kernel直接把disk的data传输给 socket，而不是通过应用程序传输。Zero-Copy大大提高了应用程序的性能，并且减少了 kernel和user模式上下文的切换

  - linux中“零拷贝” 机制使用了sendfile方法，减少了 kernel和user模式上下文的切换
  ![](https://gitee.com/jingxuanye/yjx-pictures/raw/master/pic/20200529154950.png)
  - 所谓“零拷贝”就是跳过“用户缓冲区”的拷贝，建立一个磁盘空间和内存的直接映射，数据不再复制到“用户态缓冲区


### 1.6、TCP的11种状态


## 二、http、https协议

### 2.1、什么是HTTP?

超文本传输协议，是一个基于请求与响应，无状态的，应用层的协议，常基于TCP/IP协议传输数据，互联网上应用最为广泛的一种网络协议,所有的WWW文件都必须遵守这个标准。设计HTTP的初衷是为了提供一种发布和接收HTML页面的方法。

### 2.2、http协议发展史

- HTTP/0.9
  - 1991年，不涉及数据包的传输，规定客户端和服务器之间通信格式，只能get请求。没有做为正式标准

- HTTP/1.0
  - 1996年，传输内容格式不受限制，HTTP1.0定义了三种请求方法： GET, POST 和 HEAD方法。正式作为标准

- HTTP/1.1
  - 1997年，增加持久连接，节约贷款，host域，管道机制，分块传输，新增了五种请求方法：OPTIONS, PUT, DELETE, TRACE 和 CONNECT。2015年使用最为广泛

- HTTP/2.0
  - 2015年，多路复用，服务器推送，头信息压缩，二进制协议等。逐渐覆盖市场

- http2和http1.1之间的区别
  - http2 是二进制传输
  - 头部压缩，http1.1每次都要重复请求大量都头部信息，http2只需要发送改变都头部信息就可以
  - 服务器推送：服务器可以在推送html的时候主动推送其他的一些资源
  - 多路由复用：http1.1比如我们请求2个文件，一个文件请求需要1秒，第二个文件需要等待第一个请求响应结束，才可以进行三次握手传递文件，那么时间就会增加，而http2中按流等形式进行传输，帧是流等最小单位，帧中带有下标，可以识别从哪个流来的，服务器会将帧数据重新整合成流，也就是多路由复用

### 2.3、http2的多路复用

http/1每次请求都会建立一次tcp链接，也就是我们说的三次握手四次挥手。这个过程是非常耗时的，尽管可以开启keep-alive去避免多次连接的问题。但是还是存在一下两个问题：

- 1、串行的文件传输方式。文件传输的过程是，当a文件传输时，b文件只能等待。而a文件在传输过程中，需要经历连接服务，服务器处理文件，以及断开服务等三个过程。假设每个过程耗时1s，那么a文件耗时就是3s，那么b文件传输完成就是6s
- 2、连接数过多。当客户端发起多个请求时，浏览器会对请求的并发数做一个限制，chrome的最大并发数是6个，那么第7个请求的时候就需要等前面的请求完成之后，才能拿到相应的结果。
- 3、而http2之后，改成了二进制传输，也就多了帧和流的概念。
- 4、数据在一个tcp连接中按流的形式传输，帧就是其中最小的传输单位，而帧中带有标示位，可以识别是从哪个流中来的，到服务端之后，服务端会将帧数据重新整合成流，也就是所说的多路复用。

### 2.4、http缓存
- 强缓存
  - 强缓存就是浏览器缓存，资源直接从浏览器中获取。
  - 分为两类from memory cache,from disk cache。返回的状态码都为200.
  - 两者的区别是from memory cache是从内存中取。from disk cache是从硬盘中取。如果是刷新当前页面，且内存环境比较充裕的情况下，返回from memory cache。但是如果是返回上一个页面或者当前内存环境不充裕的情况下，返回的是from disk cache。
  - 强缓存的判断标志有两个，Expires这个标识实在http1.0之前用的，表示的是过期时间，但是客户端和服务端时间存在不同步问题，所以在http1.1之后加入了Cache-Control，这个表示的是距离请求发出时的时间，是一个相对时间比较精确

- 协商缓存
  - 就是资源会从cdn去获取。
  - 协商缓存的判断标识：Last-Modified和ETag。ETag是文件每次生成的hash，是唯一的准确性高，但是比较繁琐以及消耗性能。而Last-Modified是以秒级为单位的文件生成时间，比较不精确。因为1s中文件可能多次生成。判断的优先标准是ETag。其次是Last-Modified。

- http缓存的判断过程：
  - 先判断Cache-Control的值，这里不细讲，比如max-age=300，那么在五分钟之内都会触发强缓存。如果已经过了5分钟之后，会进入协商缓存阶段。发出去的http请求中会带有两个标示位， If-Modified-Since(来自第一次请求返回头中的Last-Modified)和If-None-Match（来自第一次请求返回头中的ETag）。两个标示位的区别我在上面已经说了，根据标示位判断文件是否更新，如果更新返回状态码200以及资源。如果没有更新，只返回状态码304

- 有了【Last-Modified，If-Modified-Since】为何还要有【ETag、If-None-Match】
  - 当前时间（按秒来创建）可能会创建多个文件，所以时间可能会相同
hash值唯一不会相同

### 2.5、http报文
- 请求报文
  ```http
  请求行
  请求方式 请求路由 协议/版本
  post     /xx      http/1.1

  请求头
  accept */* //请求需要的格式
  user-agent //当前请求的浏览器信息
  host //ip || 域名
  空行 //分割主体和请求头

  请求体
  // json，fromData等
  ```
  ![](https://gitee.com/jingxuanye/yjx-pictures/raw/master/pic/20200629152831.png)

- 响应报文
  ```
  响应行
  响应头
  空行
  响应体
  ```
  ![](https://gitee.com/jingxuanye/yjx-pictures/raw/master/pic/20200629152959.png)


### 2.6、http的状态码有哪些
```http
1XX: 临时响应
2XX: 成功
    200:成功
    206:范围请求，比如最大需要200k的数据
3XX: 重定向
    301:永久重定向（不会保存之前的url 会使用新的url）
    302:临时重定向（保存之前的url 会使用新的url）
    304:强缓存还可以使用
401: 客户端错误
    400:请求错误（请求格式错误，请求头错误）
    401:需要登陆信息，需要验证身份
    403:拒绝访问
    404:没有当前资源
5XX: 服务端错误
    500:服务端发生流错误
    502:服务器错误，过载或者任务不可用
```

### 2.7、https
- 基于HTTP协议，通过SSL或TLS提供加密处理数据、验证对方身份以及数据完整性保护
- 而且HTTPS有如下特点：
  - 内容加密：采用混合加密技术，中间者无法直接查看明文内容
  - 验证身份：通过证书认证客户端访问的是自己的服务器
  - 保护数据完整性：防止传输的内容被中间人冒充或者篡改



### 2.8、https的握手过程
- 握手过程

  - 1、客户端发送请求给服务端
  - 2、服务器端拿着数字证书的公钥进行非对称加密，返回数字证书（公钥、证书信息、服务端信息、hash值）
  - 3、客户端收到服务端返回端数字证书，对数字证书进行校验（是否过期，是否正确）然后客户端生成随机数，与数字证书里的公钥进行非对称加密，返回给服务端
  - 4、服务端用私钥对当前客户端的值进行解密，获取随机数、服务端把客户端需要的数据和随机数进行对称加密返回给客户端
  - 5、客户端收到数据，（通过随机数）进行对称解密，获取数据
  - 6、之后服务端与客户端就通过随机数的对称加密方式进行交互

- HTTP和HTTPS握手差异？
  - https需要ca证书
  - tcp链接http访问80端口，https访问443端口
  - http明文，https加密
  - https 要比 http 多了证书校验，增加了通信的加密，比http安全

### 2.9、HTTPS 握手过程中，客户端如何验证证书的合法性
拿到服务端给的数字签名之后，客户端会根据机构颁发的私钥对数字签名的东西进行解密。解密出来，内部会含有服务端信息和证书的信息。
证书信息需要校验以下几方面：
1、颁发证书的第三方机构（CA）是否受客户端的信任。
2、对比系统时间校验证书是否在有效期。
3、通过CRL或者OCSP的方式校验证书是否被吊销。
4、通过校验对方是否存在证书的私钥，判断证书的网站域名是否与证书颁发的域名一致。

### 2.10、https的对称加密和非对称加密
- 对称加密
  - 加解密钥匙是同一个，密钥在传输过程中容易被第三方截取，安全性相对较低。
- 非对称加密
  - 一共有一对钥匙，分为公钥和私钥。公钥进行加密过程，私钥用于解密过程。性能上相对于对称加密来的低
- 在https中的应用
  - 由于性能原因，https只有在第一次建立的时候会使用非对称加密，之后的过程都是走随机数的对称加密方式。


### 2.11、https的安全性
- HTTPS协议的加密范围也比较有限，在黑客攻击、拒绝服务攻击、服务器劫持等方面几乎起不到什么作用
- SSL证书的信用链体系并不安全，特别是在某些国家可以控制CA根证书的情况下，中间人攻击一样可行

- 中间人攻击（MITM攻击）是指，黑客拦截并篡改网络中的通信数据。又分为被动MITM和主动MITM，被动MITM只窃取通信数据而不修改，而主动MITM不但能窃取数据，还会篡改通信数据。最常见的中间人攻击常常发生在公共wifi或者公共路由上。


### 2.12、HTTP方法具体作用
- GET: 通常用于请求服务器发送某些资源
- HEAD: 请求资源的头部信息, 并且这些头部与 HTTP GET 方法请求时返回的一致. 该请求方法的一个使用场景是在下载一个大文件前先获取其大小再决定是否要下载, 以此可以节约带宽资源
- OPTIONS: 用于获取目的资源所支持的通信选项
- POST: 发送数据给服务器
- PUT: 用于新增资源或者使用请求中的有效负载替换目标资源的表现形式
- DELETE: 用于删除指定的资源
- PATCH: 用于对资源进行部分修改
- CONNECT: HTTP/1.1协议中预留给能够将连接改为管道方式的代理服务器
TRACE: 回显服务器收到的请求，主要用于测试或诊断

### 2.13、GET和POST有什么区别？
- 数据传输方式不同：GET请求通过URL传输数据，而POST的数据通过请求体传输。
- 安全性不同：POST的数据因为在请求主体内，所以有一定的安全性保证，而GET的数据在URL中，通过历史记录，缓存很容易查到数据信息。
- 数据类型不同：GET只允许 ASCII 字符，而POST无限制
- GET无害： 刷新、后退等浏览器操作GET请求是无害的，POST可能重复提交表单
- 特性不同：GET是安全（这里的安全是指只读特性，就是使用这个方法不会引起服务器状态变化）且幂等（幂等的概念是指同一个请求方法执行多次和仅执行一次的效果完全相同），而POST是非安全非幂等

### 2.14、PUT和POST有什么区别？
- PUT 和POST方法的区别是,PUT方法是幂等的：连续调用一次或者多次的效果相同（无副作用），而POST方法是非幂等的。
- 除此之外还有一个区别，通常情况下，PUT的URI指向是具体单一资源，而POST可以指向资源集合。


### 2.15、HTTP的keep-alive是干什么的？
- 在早期的HTTP/1.0中，每次http请求都要创建一个连接，而创建连接的过程需要消耗资源和时间，为了减少资源消耗，缩短响应时间，就需要重用连接。在后来的HTTP/1.0中以及HTTP/1.1中，引入了重用连接的机制，就是在http请求头中加入Connection: keep-alive来告诉对方这个请求响应完成后不要关闭，下一次咱们还用这个请求继续交流。协议规定HTTP/1.0如果想要保持长连接，需要在请求头中加上Connection: keep-alive。

- keep-alive的优点：
  - 较少的CPU和内存的使用（由于同时打开的连接的减少了）
  - 允许请求和应答的HTTP管线化
  - 降低拥塞控制 （TCP连接减少了）
  - 减少了后续请求的延迟（无需再进行握手）
  - 报告错误无需关闭TCP连接

### 2.16、tcp、udp区别
- TCP面向连接（如打电话要先拨号建立连接）;UDP是无连接的，即发送数据之前不需要建立连接
- TCP提供可靠的服务。也就是说，通过TCP连接传送的数据，无差错，不丢失，不重复，且按序到达;UDP尽最大努力交付，即不保证可靠交付。Tcp通过校验和，重传控制，序号标识，滑动窗口、确认应答实现可靠传输。如丢包时的重发控制，还可以对次序乱掉的分包进行顺序控制。
- UDP具有较好的实时性，工作效率比TCP高，适用于对高速传输和实时性有较高的通信或广播通信。
- 每一条TCP连接只能是点到点的;UDP支持一对一，一对多，多对一和多对多的交互通信
- TCP对系统资源要求较多，UDP对系统资源要求较少。



## 三、网络相关排查应用

### 3.1、排查服务器有多少tcp连接
```
一、查看哪些IP连接本机
netstat -an
二、查看TCP连接数
1)统计80端口连接数
netstat -nat|grep -i "80"|wc -l

2）统计httpd协议连接数
ps -ef|grep httpd|wc -l

3）、统计已连接上的，状态为“established
netstat -na|grep ESTABLISHED|wc -l

4)、查出哪个IP地址连接最多,将其封了.
netstat -na|grep ESTABLISHED|awk {print $5}|awk -F: {print $1}|sort|uniq -c|sort -r +0n

netstat -na|grep SYN|awk {print $5}|awk -F: {print $1}|sort|uniq -c|sort -r +0n
```


## 参考文章
- [面试 | 你要懂得http相关](https://juejin.im/post/5ea6dcacf265da7c026bd1d1)
- [一篇文章彻底了解HTTP发展史](https://cloud.tencent.com/developer/article/1513007)