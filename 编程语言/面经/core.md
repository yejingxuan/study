- [一、JAVA基础](#%e4%b8%80java%e5%9f%ba%e7%a1%80)
- [二、JVM](#%e4%ba%8cjvm)
- [三、DB](#%e4%b8%89db)
  - [3.1、mysql的存储引擎](#31mysql%e7%9a%84%e5%ad%98%e5%82%a8%e5%bc%95%e6%93%8e)
  - [3.2、三范式](#32%e4%b8%89%e8%8c%83%e5%bc%8f)
  - [3.3、索引](#33%e7%b4%a2%e5%bc%95)
  - [3.3、事务](#33%e4%ba%8b%e5%8a%a1)
  - [3.4、SQL优化](#34sql%e4%bc%98%e5%8c%96)
  - [3.5、数据库锁](#35%e6%95%b0%e6%8d%ae%e5%ba%93%e9%94%81)
  - [3.6、分库分表](#36%e5%88%86%e5%ba%93%e5%88%86%e8%a1%a8)
- [四、Kafka](#%e5%9b%9bkafka)
  - [4.1、两种消息模型](#41%e4%b8%a4%e7%a7%8d%e6%b6%88%e6%81%af%e6%a8%a1%e5%9e%8b)
- [五、RabbitMQ](#%e4%ba%94rabbitmq)
- [六、Redis](#%e5%85%adredis)
  - [6.1、Reids数据类型](#61reids%e6%95%b0%e6%8d%ae%e7%b1%bb%e5%9e%8b)
  - [6.2、缓存雪崩 & 缓存穿透、缓存击穿](#62%e7%bc%93%e5%ad%98%e9%9b%aa%e5%b4%a9--%e7%bc%93%e5%ad%98%e7%a9%bf%e9%80%8f%e7%bc%93%e5%ad%98%e5%87%bb%e7%a9%bf)
  - [6.3、分布式锁](#63%e5%88%86%e5%b8%83%e5%bc%8f%e9%94%81)
  - [6.4、延时队列](#64%e5%bb%b6%e6%97%b6%e9%98%9f%e5%88%97)
  - [6.5、Redis持久化](#65redis%e6%8c%81%e4%b9%85%e5%8c%96)
  - [6.6、同步机制](#66%e5%90%8c%e6%ad%a5%e6%9c%ba%e5%88%b6)
  - [6.7、集群高可用](#67%e9%9b%86%e7%be%a4%e9%ab%98%e5%8f%af%e7%94%a8)
- [七、分布式](#%e4%b8%83%e5%88%86%e5%b8%83%e5%bc%8f)
- [八、Design Pattern](#%e5%85%abdesign-pattern)

## 一、JAVA基础

## 二、JVM

## 三、DB

### 3.1、mysql的存储引擎

  - __InnoDB：__
    - InnoDB 底层存储结构为B+树， B树的每个节点对应innodb的一个page， page大小是固定的，
      一般设为 16k。其中非叶子节点只有键值，叶子节点包含完成数据

    - 适用场景：
      1）经常更新的表，适合处理多重并发的更新请求。
      2）支持事务。
      3）可以从灾难中恢复（通过 bin-log 日志等）。
      4）外键约束。只有他支持外键。
      5）支持自动增加列属性 auto_increment。
  
  - __MyIsam：__
    - MyIASM是 MySQL默认的引擎，但是它没有提供对数据库事务的支持，也不支持行级锁和外键，
      因此当 INSERT(插入)或 UPDATE(更新)数据时即写操作需要锁定整个表，效率便会低一些。

    - ISAM 执行读取操作的速度很快，而且不占用大量的内存和存储资源。在设计之初就预想数据组织
      成有固定长度的记录，按顺序存储的。 ---ISAM 是一种静态索引结构。

  - __Memory：__
    - Memory（也叫 HEAP）堆内存：使用存在内存中的内容来创建表。每个 MEMORY 表只实际对应
      一个磁盘文件。 MEMORY 类型的表访问非常得快，因为它的数据是放在内存中的，并且默认使用
      HASH 索引。但是一旦服务关闭，表中的数据就会丢失掉。 Memory 同时支持散列索引和 B 树索
      引， B树索引可以使用部分查询和通配查询，也可以使用<,>和>=等操作符方便数据挖掘，散列索
      引相等的比较快但是对于范围的比较慢很多

  - __Sequence：__

  - __CSV：__

  - __Aria：__

### 3.2、三范式

  - __第一范式：__
    - 表的列的具有原子性,不可再分解，即列的信息，不能分解，通俗理解即一个字段只存储一项信息。

  - __第二范式：__
    - 首先满足第一范式，并且数据库表中的每个实例或行必须可以被惟一地区分。为实现区分通常需要我们设计一个主键来实现(这里的主键不包含业务逻辑)。
    
    - 即满足第一范式前提，当存在多个主键的时候，才会发生不符合第二范式的情况。比如有两个主键，不能存在这样的属性，它只依赖于其中一个主键，这就是不符合第二范式。通俗理解是任意一个字段都只依赖表中的同一个字段。（涉及到表的拆分）
  
  - __第三范式：__
    - 第三范式定义是，满足第二范式，并且表中不包含已在其它表中已包含的非主键字段
    - 表的信息，如果能够被推导出来，就不应该单独的设计一个字段来存放(能尽量外键join就用外键join)。很多时候，我们为了满足第三范式往往会把一张表分成多张表。

### 3.3、索引

### 3.3、事务
事务(TRANSACTION)是作为单个逻辑工作单元执行的一系列操作， 这些操作作为一个整体一起向系统提交，要么都执行、要么都不执行 。 事务是一个不可分割的工作逻辑单元事务必须具备以下四个属性，简称 ACID 属性：

  - __原子性：__
    - 事务是一个完整的操作。事务的各步操作是不可分的（原子的）；要么都执行，要么都不执行

  - __一致性：__
    - 当事务完成时，数据必须处于一致状态

  - __隔离性：__
    - 对数据进行修改的所有并发事务是彼此隔离的， 这表明事务必须是独立的，它不应以任何方式依赖于或影响其他事务

  - __永久性：__
    - 事务完成后，它对数据库的修改被永久保持，事务日志能够保持事务的永久性

### 3.4、SQL优化

### 3.5、数据库锁

  - __行级锁：__
    - 行级锁是一种排他锁，防止其他事务修改此行；在使用以下语句时， Oracle 会自动应用行级锁：
      1. INSERT、 UPDATE、 DELETE、 SELECT … FOR UPDATE [OF columns] [WAIT n | NOWAIT];
      2. SELECT … FOR UPDATE 语句允许用户一次锁定多条记录进行更新
      3. 使用 COMMIT 或 ROLLBACK 语句释放锁

  - __表级锁：__
    - 表示对当前操作的整张表加锁，它实现简单，资源消耗较少，被大部分 MySQL 引擎支持。最常使用的 MYISAM 与 INNODB 都支持表级锁定。表级锁定分为表共享读锁（共享锁）与表独占写锁（排他锁）

  - __间隙锁：__

  - __页级锁：__
    - 页级锁是 MySQL 中锁定粒度介于行级锁和表级锁中间的一种锁。表级锁速度快，但冲突多，行级冲突少，但速度慢。所以取了折衷的页级，一次锁定相邻的一组记录。 BDB 支持页级锁

### 3.6、分库分表

  - __垂直切分：__
    - 将表按照功能模块、关系密切程度划分出来， 部署到不同的库上。例如，我们会建立定义数据库 workDB、商品数据库 payDB、用户数据库 userDB、日志数据库 logDB 等，分别用于存储项目数据定义表、商品定义表、用户数据表、日志数据表等
    ![](https://gitee.com/jingxuanye/yjx-pictures/raw/master/pic/20200424180152.png)

  - __水平切分：__
    - 按照规则划分存储，当一个表中的数据量过大时，我们可以把该表的数据按照某种规则，例如 userID 散列，进行划分，然后存储到多个结构相同的表，和不同的库上
    ![](https://gitee.com/jingxuanye/yjx-pictures/raw/master/pic/20200424180117.png)

## 四、Kafka

### 4.1、两种消息模型

  - __点对点：__


  - __发布订阅：__

## 五、RabbitMQ

## 六、Redis

### 6.1、Reids数据类型
  - __String：__
    - 这是最简单的类型，就是普通的 set 和 get，做简单的 KV 缓存。
    - 许多系统都会使用Redis作为系统的实时计数器，可以快速实现计数和查询的功能。而且最终的数据结果可以按照特定的时间落地到数据库或者其它存储介质当中进行永久保存。例如秒杀场景
    - 共享用户Session：用户重新刷新一次界面，可能需要访问一下数据进行重新登录，或者访问页面缓存Cookie，但是可以利用Redis将用户的Session集中管理，在这种模式只需要保证Redis的高可用，每次用户Session的更新和获取都可以快速完成。大大提高效率
  
  - __Hash：__
    - 类似 Map 的一种结构，这个一般就是可以将结构化的数据，比如一个对象（前提是这个对象没嵌套其他的对象）给缓存在 Redis 里，然后每次读写缓存的时候，可以就操作 Hash 里的某个字段
    - 做数据字典使用
  
  - __List：__
    - List 是有序列表，可以通过 List 存储一些列表型的数据结构，类似粉丝列表、文章的评论列表之类的东西。
    - 可以通过 lrange 命令，读取某个闭区间内的元素，可以基于 List 实现分页查询，这个是很棒的一个功能，基于 Redis 实现简单的高性能分页，可以做类似微博那种下拉不断分页的东西，性能高，就一页一页走
    - 可以搞个简单的消息队列，从 List 头怼进去，从 List 屁股那里弄出来
  
  - __Set：__
    - Set 是无序集合，会自动去重
  
  - __SortSet：__
    - 是排序的 Set，去重但可以排序，每个元素都会关联一个double类型的分数。通过分数来为集合中的成员进行从小到大的排序
    - 排行榜：有序集合经典使用场景。例如视频网站需要对用户上传的视频做排行榜，榜单维护可能是多方面：按照时间、按照播放量、按照获得的赞数等。
    - 用Sorted Sets来做带权重的队列，比如普通消息的score为1，重要消息的score为2，然后工作线程可以选择按score的倒序来获取工作任务。让重要的任务优先执行。
    - 可用来做延时队列
  
  - __HyperLogLog：__
    - Redis 在 2.8.9 版本添加了 HyperLogLog 结构。用来做基数统计,在输入元素的数量或者体积非常非常大时，计算基数所需的空间总是固定 的、并且是很小的。
    - 每个 HyperLogLog 键只需要花费 12 KB 内存，就可以计算接近 2^64 个不同元素的基 数
    - 因为 HyperLogLog 只会根据输入元素来计算基数，而不会储存输入元素本身，所以 HyperLogLog 不能像集合那样，返回输入的各个元素。

  - __Geo：__
    - GEO功能在Redis3.2版本提供，支持存储地理位置信息，用来实现诸如附近位置、摇一摇这类依赖于地理位置信息的功能.geo的数据类型为zset
  
  - __Pub/Sub：__
    - 发布订阅模式，做简单的消息中间件，缺点是消息无法持久化，消费者掉线中，此时生产者有新消息产生后会丢失。
    - 订阅发布可以支持多客户端获取同一个频道发布的消息，当有新消息通过 PUBLISH 命令发送给频道 channel1 时， 这个消息就会被发送给订阅它的所有客户端。
  
  - __BloomFilter：__
    - 布隆过滤器，解决缓存穿透问题
  
  - __RedisSearch：__
    - 全文检索功能服务

### 6.2、缓存雪崩 & 缓存穿透、缓存击穿

  - __缓存雪崩：__

    - 目前电商首页以及热点数据都会去做缓存 ，一般缓存都是定时任务去刷新，或者是查不到之后去更新的，定时任务刷新就有一个问题  

    - a. 处理缓存雪崩简单，在批量往Redis存数据的时候，把每个Key的失效时间都加个随机值就好了，这样可以保证数据不会在同一时间大面积失效，我相信，Redis这点流量还是顶得住的。setRedis（Key，value，time + Math.random() * 10000）；

    - b. 或者设置热点数据永远不过期，有更新操作就更新缓存就好了（比如运维更新了首页商品，那你刷下缓存就完事了，不要设置过期时间），电商首页的数据也可以用这个操作，保险  

  - __缓存穿透：__
    
    - 缓存穿透是指缓存和数据库中都没有的数据，而用户不断发起请求，我们数据库的 id 都是1开始自增上去的，如发起为id值为 -1 的数据或 id 为特别大不存在的数据。这时的用户很可能是攻击者，攻击会导致数据库压力过大，严重会击垮数据库  

    - 在接口层增加校验，比如用户鉴权校验，参数做校验，不合法的参数直接代码Return
  
    - 布隆过滤器（Bloom Filter）这个也能很好的防止缓存穿透的发生，他的原理也很简单就是利用高效的数据结构和算法快速判断出你这个Key是否在数据库中存在，不存在你return就好了，存在你就去查了DB刷新KV再return。


  - __缓存击穿：__

    - 至于缓存击穿嘛，这个跟缓存雪崩有点像，但是又有一点不一样，缓存雪崩是因为大面积的缓存失效，打崩了DB，而缓存击穿不同的是缓存击穿是指一个Key非常热点，在不停的扛着大并发，大并发集中对这一个点进行访问，当这个Key在失效的瞬间，持续的大并发就穿破缓存，直接请求数据库，就像在一个完好无损的桶上凿开了一个洞

    - 设置热点数据永远不过期。或者加上互斥锁就能搞定了。


### 6.3、分布式锁

### 6.4、延时队列

使用sortedset，拿时间戳作为score，消息内容作为key调用zadd来生产消息，消费者用zrangebyscore指令获取N秒之前的数据轮询进行处理

### 6.5、Redis持久化

- __RDB：__ RDB 持久化机制，是对 Redis 中的数据执行周期性的持久化

- __AOF：__ AOF 机制对每条写入命令作为日志，以 append-only 的模式写入一个日志文件中，因为这个模式是只追加的方式，所以没有任何磁盘寻址的开销，所以很快，有点像Mysql中的binlog

### 6.6、同步机制

### 6.7、集群高可用



## 七、分布式

## 八、Design Pattern

