# zookeeper实现分布式锁

> 参考文章：[zookeeper实现分布式锁](https://www.cnblogs.com/liuyang0/p/6800538.html)  
[基于Zookeeper的分布式锁](https://baijiahao.baidu.com/s?id=1593258103626631655&wfr=spider&for=pc)

## 一、基于ZooKeeper分布式锁的流程


### 1、理解zookeeper分布式锁之前需要了解zookeeper的几个特性
- 有序节点：假如当前有一个父节点为/lock-name,我们可以再父节点下创建子节点；zookeeper提供了一个可选的有序特性，

- 临时节点：客户端可以建立一个临时节点，在会话结束或者会话超时后，zookeeper会自动删除该节点。

- 事件监听：在读取数据时我们可以同时对事件设置监听，当节点数据或者结构变化时，zookeeper会通知客户端。当前zookeeper下有四种监听事件：1)节点创建；2)节点删除；3)节点数据修改；4)子节点变更。

### 2、zookeeper分布式锁具体流程

#### 实现流程：
1. 在zookeeper指定节点（locks）下创建临时顺序节点node_n

2. 获取locks下所有子节点children

3. 对子节点按节点自增序号从小到大排序

4. 判断本节点是不是第一个子节点，若是，则获取锁；若不是，则监听比该节点小的那个节点的删除事件

5. 若监听事件生效，则回到第二步重新进行判断，直到获取到锁

> 场景1：客户端a对应子节点为/lock/lock-0000000000，客户端b对应子节点为/lock/lock-0000000001，客户端b获取子节点列表时发现自己不是序号最小的，但是在设置监听器前客户端a完成业务流程删除了子节点/lock/lock-0000000000，客户端b设置的监听器岂不是丢失了这个事件从而导致永远等待了？
>
>__这个问题不存在的。因为zookeeper提供的API中设置监听器的操作与读操作是原子执行的，也就是说在读子节点列表时同时设置监听器，保证不会丢失事件。__


> 场景2：假如当前有1000个节点在等待锁，如果获得锁的客户端释放锁时，这1000个客户端都会被唤醒，这种情况称为“羊群效应”；在这种羊群效应中，zookeeper需要通知1000个客户端，这会阻塞其他的操作，最好的情况应该只唤醒新的最小节点对应的客户端。应该怎么做呢？
>
>__在设置事件监听时，每个客户端应该对刚好在它之前的子节点设置事件监听，例如子节点列表为/lock/lock-0000000000、/lock/lock-0000000001、/lock/lock-0000000002，序号为1的客户端监听序号为0的子节点删除消息，序号为2的监听序号为1的子节点删除消息。__
