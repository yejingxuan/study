# JAVA集合详解

> 参考文章: https://www.toutiao.com/i6657333580445778435/

## 一、List集合

### 1. ArrayList

- ArrayList是List接口的实现类，插入的元素是有序的，其顺序就是插入时的先后顺序，__ArrayList底层实现为动态数组__，默认大小为10，每次添加元素时会检查容量是否超过出示容量，如果超出则进行扩容（int newCapacity = (oldCapacity * 3)/2 + 1;）

- ArrayList底层实现是数组，所以我们如果知道元素的下标，那么就能很快的定位到相关元素，所以其查询性能高，但是添加会涉及到数组中其他元素的移动，所以性能不佳。

- 所以在使用ArrayList的时候，如果可以尽量估算一个初始容量，减少扩容频率，同时尽量将ArrayList用于查询操作非常添加操作的集合


### 2. Vector

- Vector同样实现了List接口，Vector与ArrayList的底层实现是一样的，只不过Vector是ArrayList的线程安全版本，因为Vector采用synchronize关键字修饰所有方法，在多线程环境下，只有一个线程能够操作Vector，但是如果存在线程安全问题的话Vector的效率要低于ArrayList，因为Vector会涉及到获取锁和释放锁

### 3. LinkedList

- LinkedList同样实现了List接口，插入元素的仍然是有序，其顺序就是插入时的先后顺序，__LinkedList底层是以双向链表的结构实现的__，链表的特点就是在内存中不是连续的内存分布，而是通过指针相连，所以其查找速度不如ArrayList，但是由于链表不是连续的，所以其添加和删除的性能要优于ArrayList，因为我们添加和删除元素不会涉及到其他元素的移动。

---


## 二、Set集合

### 1. HashSet

- HashSet是Set接口的实现类，Set接口的实现类，不允许元素的重复，HashSet的底层实现是基于HashMap实现的，只不过HashSet只使用了HashMap的key部分而已，HashMap的Value部分被一个统一个Object对象代替，HashSet是基于Hash算法实现，所以我们在使用HashSet作为容器是，我们添加的元素需要重写hashCode和equals方法，HashSet集合允许一个key为null

### 2. TreeSet

- TreeSet是基于TreeMap实现的。TreeSet中的元素支持2种排序方式：自然排序 或者 根据创建TreeSet 时提供的 Comparator 进行排序。这取决于使用的构造方法

- TreeSet的本质是一个"有序的，并且没有重复元素"的集合，它是通过TreeMap实现的。TreeSet中含有一个NavigableMap类型的成员变量m，而m实际上是TreeMap的实例。

### 3. LinkedHashSet

- LinkedHashSet集合同样是根据元素的hashCode值来决定元素的存储位置，但是它同时使用链表维护元素的次序。这样使得元素看起 来像是以插入顺序保存的，也就是说，当遍历该集合时候，LinkedHashSet将会以元素的添加顺序访问集合的元素