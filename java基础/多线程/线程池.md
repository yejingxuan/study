# 多线程学习

### 参考文章：https://www.cnblogs.com/ruiati/p/6134131.html


## 实现多线程的几种方法

1. 直接new Thread 实现

        new Thread(new Runnable() {
            @Override
            public void run() {
                // TODO Auto-generated method stub
                }
            }
        ).start();

        a. 每次new Thread新建对象性能差。
        b. 线程缺乏统一管理，可能无限制新建线程，相互之间竞争，及可能占用过多系统资源导致死机或oom。
        c. 缺乏更多功能，如定时执行、定期执行、线程中断。

2. 继承Thread类实现

        public class MyThread extends Thread {  
        　　public void run() {  
        　　 System.out.println("MyThread.run()");  
        　　}  
        }  

        线程命名：new MyThread().setName("线程1")

3. 实现runable接口 

        public class MyThread implements Runnable {  
        　　public void run() {  
        　　 System.out.println("MyThread.run()");  
        　　}  
        } 

4. 线程池实现


## java中给多线程中子线程传递参数的三种方式

1. 通过构造函数传递参数

         public class MyThread extends Thread {
            private Ticket ticket;	
            public MyTicketThread(Ticket ticket) {
                super();
                this.ticket = ticket;
            }  
        　　public void run() {  
        　　 System.out.println("MyThread.run()");  
        　　} 
        } 

2. 通过变量和方法传递数据

3. 通过回调函数传递数据




## 什么是线程池 

       java.util.concurrent.Executors提供了一个 java.util.concurrent.Executor接口的实现用于创建线程池

* newCachedThreadPool创建一个可缓存线程池，如果线程池长度超过处理需要，可灵活回收空闲线程，若无可回收，则新建线程。

* newFixedThreadPool 创建一个定长线程池，可控制线程最大并发数，超出的线程会在队列中等待。

* newScheduledThreadPool 创建一个定长线程池，支持定时及周期性任务执行。

* newSingleThreadExecutor 创建一个单线程化的线程池，它只会用唯一的工作线程来执行任务，保证所有任务按照指定顺序(FIFO, LIFO, 优先级)执行。