# 多线程学习

>参考文章：https://www.cnblogs.com/ruiati/p/6134131.html  
https://www.toutiao.com/i6615390387525648899/


## 一、实现多线程的几种方法

### 1. 直接new Thread 实现
```java
new Thread(new Runnable() {
    @Override
    public void run() {
        // TODO Auto-generated method stub
        }
    }
).start();
```
- a. 每次new Thread新建对象性能差。
- b. 线程缺乏统一管理，可能无限制新建线程，相互之间竞争，及可能占用过多系统资源导致死机或oom。
- c. 缺乏更多功能，如定时执行、定期执行、线程中断。

### 2. 继承Thread类实现

```java
public class MyThread extends Thread {  
　　public void run() {  
　　 System.out.println("MyThread.run()");  
　　}  
}  
```
- 线程命名：new MyThread().setName("线程1")

### 3. 实现runable接口 

```java
public class MyThread implements Runnable {  
　　public void run() {  
　　 System.out.println("MyThread.run()");  
　　}  
} 
```

### 4. 线程池实现

- 通过java.util.concurrent.Executors提供的构造方法实现。


---

## 二、java中给多线程中子线程传递参数的三种方式

1. 通过构造函数传递参数

    ```java
    public class MyThread extends Thread {
        private Ticket ticket;	
        public MyTicketThread(Ticket ticket) {
            super();
            this.ticket = ticket;
        }  
    　　public void run() {  
    　　 System.out.println("MyThread.run()");  
    　　} 
    } 
    ```


2. 通过变量和方法传递数据



3. 通过回调函数传递数据



-----

## 三、什么是线程池 

> java.util.concurrent.Executors提供了一个 java.util.concurrent.Executor接口的实现用于创建线程池


> Executors提供了四种创建不通类型线程池的工厂方法，通过new ThreadPoolExecutor()传递不同参数来创建不同类型线程池

### 1. ThreadPoolExecutor构造方法详解：

|参数名 |作用|
|:--:|:--:|
|corePoolSize   |核心线程池大小|
|maximumPoolSize|最大线程池大小|
|keepAliveTime  |线程池中超过corePoolSize数目的空闲线程最大存活时间|
|TimeUnit       |keepAliveTime时间单位|
|workQueue      |阻塞任务队列|



### 2. 四类线程池介绍：

* newCachedThreadPool创建一个可缓存线程池，如果线程池长度超过处理需要，可灵活回收空闲线程，若无可回收，则新建线程。

    创建一个可缓存线程池，代码示例：

    ```java
    public void doCachedThreadPool() {
		Ticket ticket = new Ticket();
		ticket.setTotal(1000);
		
		ExecutorService cachedThreadPool = Executors.newCachedThreadPool();
		
		for (int i = 0; i < ticket.getTotal(); i++) {
			final int a = i;
			cachedThreadPool.execute(new Runnable() {
				@Override
				public void run() {					
					System.out.println(a+"————:"+Thread.currentThread().getName());
				}
			
			});
		}
	}

    ```

    源码详解：
    ```java
    ExecutorService cachedThreadPool = Executors.newCachedThreadPool();

    public static ExecutorService newCachedThreadPool() {
        return new ThreadPoolExecutor(0, Integer.MAX_VALUE,
                                        60L, TimeUnit.SECONDS,
                                        new SynchronousQueue<Runnable>());
    }
    ```


* newFixedThreadPool 创建一个定长线程池，可控制线程最大并发数，超出的线程会在队列中等待。

    创建一个定长线程池，代码示例：
    ```java
    public void doFixedThreadPool() {
		Ticket ticket = new Ticket();
		ticket.setTotal(1000);
		
		ExecutorService fixedThreadPool = Executors.newFixedThreadPool(5);
		
		for (int i = 0; i < 1000; i++) {
			final int a = i;
			fixedThreadPool.execute(new Runnable() {
				@Override
				public void run() {					
					System.out.println(a+"————:"+Thread.currentThread().getName());
				}
			
			});
		}
		
	}
    ```

    源码详解：

    ```java
    ExecutorService fixedThreadPool = Executors.newFixedThreadPool(5);

    public static ExecutorService newFixedThreadPool(int nThreads) {
        return new ThreadPoolExecutor(nThreads, nThreads,
                                        0L, TimeUnit.MILLISECONDS,
                                        new LinkedBlockingQueue<Runnable>());
    }
    ```


* newScheduledThreadPool 创建一个定长线程池，支持定时及周期性任务执行。

    ```java
    ScheduledExecutorService scheduledThreadPool = Executors.newScheduledThreadPool(10);

    //等待一秒后，每两秒执行一次			
    scheduledThreadPool.scheduleAtFixedRate(new Runnable() {			 
        @Override
        public void run() {
            System.out.println("————:"+Thread.currentThread().getName());
            
        }
    }, 1, 2, TimeUnit.SECONDS);
    
    //等待三秒后执行
    scheduledThreadPool.schedule(new Runnable() {				
        @Override
        public void run() {				
            System.out.println("————:"+Thread.currentThread().getName());
        }
    }, 5, TimeUnit.SECONDS);
    ```


    ```java  
    //创建线程池
    ScheduledExecutorService scheduledThreadPool = Executors.newScheduledThreadPool(5);
    //执行线程任务
    scheduledThreadPool.schedule(new Runnable() {
        @Override
        public void run() {
            System.out.println("delay 3 seconds");
        }
    }, 3, TimeUnit.SECONDS);


    //线程池源码
    public static ScheduledExecutorService newScheduledThreadPool(int corePoolSize) {
        return new ScheduledThreadPoolExecutor(corePoolSize);
    }

    public class ScheduledThreadPoolExecutor extends ThreadPoolExecutor implements ScheduledExecutorService {     
        ...
        public ScheduledThreadPoolExecutor(int corePoolSize) {
            super(corePoolSize, Integer.MAX_VALUE, 0, NANOSECONDS,
                new DelayedWorkQueue());
        }
        ...
    }


    ```



* newSingleThreadExecutor 创建一个单线程化的线程池，它只会用唯一的工作线程来执行任务，保证所有任务按照指定顺序(FIFO, LIFO, 优先级)执行。

    ```java
    ExecutorService fixedThreadPool = Executors.newSingleThreadExecutor();

    public static ExecutorService newSingleThreadExecutor() {
        return new FinalizableDelegatedExecutorService
            (new ThreadPoolExecutor(1, 1,
                                    0L, TimeUnit.MILLISECONDS,
                                    new LinkedBlockingQueue<Runnable>()));
    }

    ```