# 分布式锁实现

[TOC]

> 参考文章： [Redis 分布式锁的正确实现方式（ Java 版 ）](http://www.importnew.com/27477.html)

## 一、概述

### 1.1、啥是分布式锁


### 1.2、为什么要实现分布式锁
- 解决分布式应用在高并发情况下出现的线程安全问题。

### 1.3、应用场景


## 二、实现原理

- 原子性：同一时刻，只能有一个机器的一个线程得到锁；
- 可重入性：同一对象（如线程、类）可以重复、递归调用该锁而不发生死锁；
- 可阻塞：在没有获得锁之前，只能阻塞等待直至获得锁；
- 高可用：哪怕发生程序故障、机器损坏，锁仍然能够得到被获取、被释放；
- 高性能：获取、释放锁的操作消耗小。


## 三、实现方式

### 3.1、基于redis的分布式锁实现
http://developer.51cto.com/art/201812/588335.htm

实现原理：  
- redis的原子性
- redis的单线程操作
- redis的高性能

#### 3.1.1、springboot集成redis分布式锁

springboot集成redis所需jar包
```xml
<!-- redis集成所需jar包-->
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-data-redis</artifactId>
    <exclusions>
        <!--一不依赖 Redis 的异步客户端 lettuce -->
        <exclusion>
            <groupId>io.lettuce</groupId>
            <artifactId>lettuce-core</artifactId>
        </exclusion>
    </exclusions>
</dependency>

<dependency>
    <groupId>redis.clients</groupId>
    <artifactId>jedis</artifactId>
</dependency>
```


定义分布式锁接口

```java
/**
 * @Author yejingxuan
 * @Description 分布式锁接口
 * @Date  15:01
 **/
public interface DistributeLock {
    //获取锁
    boolean getLock(String key, String uuid);
    //释放锁
    boolean unLock(String key, String uuid);
}
```
实现redis分布式锁
```java
/**
 * @Author yejingxuan
 * @Description 基于redis的分布式锁实现
 * @Date 15:03
 **/
@Service
@Slf4j
public class RedisDistributeLockImpl implements DistributeLock {

    //分布式锁的名称
    @Value("${DISTRIBUTED.LOCK.KEY:redis:lock:}")
    private String DISTRIBUTED_LOCK_KEY;
    //分布式锁的超时时间（秒）
    @Value("${DISTRIBUTED.LOCK.TIMEOUT:5}")
    private Integer DISTRIBUTED_LOCK_TIMEOUT;
    //分布式锁的等待时间（毫秒）
    @Value("${DISTRIBUTED.LOCK.WAITTIME:200}")
    private Integer DISTRIBUTED_LOCK_WAITTIME;

    @Autowired
    private RedisTemplate<Object, Object> redisTemplate;


    /**
     * @return java.lang.Boolean
     * @Author yejingxuan
     * @Description 获取分布式锁
     * @Date 14:46
     * @Param [key, uuid]
     **/
    @Override
    public boolean getLock(String key, String uuid) {
        Boolean lock = false;
        key = DISTRIBUTED_LOCK_KEY + key;
        lock = redisTemplate.opsForValue()
                .setIfAbsent(key, uuid, DISTRIBUTED_LOCK_TIMEOUT, TimeUnit.SECONDS);

        while (!lock) {
            log.info(key + ":" + uuid + "未获得锁,重入");
            //随机进行线程等待
            try {
                TimeUnit.MILLISECONDS.sleep(DISTRIBUTED_LOCK_WAITTIME + new Random().nextInt(100));
            } catch (InterruptedException e) {
                log.error(e);
            }
            //重入
            lock = redisTemplate.opsForValue()
                    .setIfAbsent(key, uuid, DISTRIBUTED_LOCK_TIMEOUT, TimeUnit.SECONDS);
        }

        log.info(key + ":" + uuid + "获得锁");
        return lock;
    }


    /**
     * @return java.lang.Boolean
     * @Author yejingxuan
     * @Description 解开分布式锁
     * @Date 14:46
     * @Param [key, uuid]
     **/
    @Override
    public boolean unLock(String key, String uuid) {
        Boolean res = false;

        DefaultRedisScript<Boolean> script = new DefaultRedisScript<Boolean>();
        script.setResultType(Boolean.class);
        script.setScriptText("if redis.call('get', KEYS[1]) == ARGV[1] "
                + "then "
                + "return redis.call('del', KEYS[1]) else return 0 end");

        //List设置lua的KEYS
        List<String> keyList = new ArrayList();
        keyList.add(DISTRIBUTED_LOCK_KEY + key);

        res = redisTemplate.execute(script, Collections.singletonList(keyList.get(0)), uuid);
        if (res) {
            log.info(key + ":" + uuid + "释放锁");
        } else {
            log.info(key + ":" + uuid + "未释放锁");
        }

        return res;
    }

}
```




### 3.2、基于zookeeper的分布式锁实现

[zookeeper分布式锁](https://baijiahao.baidu.com/s?id=1593258103626631655&wfr=spider&for=pc)





### 3.3、基于etcd的分布式锁实现

etcd采用Raft算法保证数据的强一致性，某次操作存储到集群中的值必然是全局一致的，所以很容易实现分布式锁。锁服务有两种使用方式，一是保持独占，二是控制时序

https://www.oschina.net/p/jetcd

https://blog.csdn.net/qq_15769369/article/details/82693107


https://segmentfault.com/a/1190000019411892?utm_source=tag-newest

etcd是一个分布式可靠的键值存储系统。它提供了与ZooKeeper相似的功能，但是使用Go语言编写而不是Java语言。Etcd使用Raft协调算法而不是ZooKeeper采用的Paxos算法。在云计算方面，Go是一个大有前景的语言，被誉为云时代的C语言。

对比与ZooKeeper，etcd更轻量级，etc更加关注一下几点：

l简单：curl命令可以调用的API接口（http+JSON）

l保密：可选的SSL客户端认证

l快速：标准检测每个实例每秒1000读写能力

l可靠：恰到地实现分布式协调，采用Raft一致性算法



保持独占，即所有试图获取锁的用户最终只有一个可以得到。etcd为此提供了一套实现分布式锁原子操作CAS（CompareAndSwap）的API。通过设置prevExist值，可以保证在多个节点同时创建某个目录时，只有一个成功，而该用户即可认为是获得了锁。
控制时序，即所有试图获取锁的用户都会进入等待队列，获得锁的顺序是全局唯一的，同时决定了队列执行顺序。etcd为此也提供了一套API（自动创建有序键），对一个目录建值时指定为POST动作，这样etcd会自动在目录下生成一个当前最大的值为键，存储这个新的值（客户端编号）。同时还可以使用API按顺序列出所有当前目录下的键值。此时这些键的值就是客户端的时序，而这些键中存储的值可以是代表客户端的编号。