# 七种结构型设计模式

>参考文章：https://blog.csdn.net/zhangerqing/article/details/8239539 
https://blog.csdn.net/lovelion/article/details/17517213?tdsourcetag=s_pctim_aiomsg

## 一、适配器模式(Adapter)

>适配器模式将某个类的接口转换成客户端期望的另一个接口表示，目的是消除由于接口不匹配所造成的类的兼容性问题。主要分为三类：类的适配器模式、对象的适配器模式、接口的适配器模式


### 1. 类的适配器


### 2. 对象适配器


### 3. 接口适配器





## 二、装饰模式(Decorator)

>装饰模式就是给一个对象增加一些新的功能，而且是动态的，要求装饰对象和被装饰对象实现同一个接口，装饰对象持有被装饰对象的实例



## 三、代理模式(Proxy)

>代理模式就是多一个代理类出来，替原对象进行一些操作，比如我们在租房子的时候回去找中介，为什么呢？因为你对该地区房屋的信息掌握的不够全面，希望找一个更熟悉的人去帮你做，此处的代理就是这个意思。再如我们有的时候打官司，我们需要请律师，因为律师在法律方面有专长，可以替我们进行操作，表达我们的想法



- __代理模式和装饰模式的区别__

    PS：两个设计模式看起来很像。对装饰器模式来说，装饰者（decorator）和被装饰者（decoratee）都实现同一个 接口。对代理模式来说，代理类（proxy class）和真实处理的类（real class）都实现同一个接口。此外，不论我们使用哪一个模式，都可以很容易地在真实对象的方法前面或者后面加上自定义的方法。

    然而，实际上，在装饰器模式和代理模式之间还是有很多差别的。装饰器模式关注于在一个对象上动态的添加方法，然而代理模式关注于控制对对象的访问。换句话 说，用代理模式，代理类（proxy class）可以对它的客户隐藏一个对象的具体信息。因此，当使用代理模式的时候，我们常常在一个代理类中创建一个对象的实例。并且，当我们使用装饰器模 式的时候，我们通常的做法是将原始对象作为一个参数传给装饰者的构造器。

    我们可以用另外一句话来总结这些差别：使用代理模式，代理和真实对象之间的的关系通常在编译时就已经确定了，而装饰者能够在运行时递归地被构造。



## 四、外观模式(Facade)

> 为子系统中的一组接口提供一个统一的入口。外观模式定义了一个高层接口，这个接口使得这一子系统更加容易使用。外观模式就是将他们的关系放在一个Facade类中，降低了类类之间的耦合度，该模式中没有涉及到接口

外观模式又称为门面模式，它是一种对象结构型模式。__外观模式是迪米特法则的一种具体实现__，通过引入一个新的外观角色可以降低原有系统的复杂度，同时降低客户类与子系统的耦合度。


```java

public class CPU {	
	public void startup(){
		System.out.println("cpu startup!");
	}
}

public class Disk {	
	public void startup(){
		System.out.println("disk startup!");
	}
}

public class Computer {
	private CPU cpu;
	private Disk disk;
	
	public Computer(){
		cpu = new CPU();
		disk = new Disk();
	}
	
	public void startup(){
		System.out.println("start the computer!");
		cpu.startup();
		disk.startup();
		System.out.println("start computer finished!");
	}
}

```



## 五、桥接模式(Bridge)

>桥接模式就是把事物和其具体实现分开，使他们可以各自独立的变化。桥接的用意是：将抽象化与实现化解耦，使得二者可以独立变化，像我们常用的JDBC桥DriverManager一样，JDBC进行连接数据库的时候，在各个数据库之间进行切换，基本不需要动太多的代码，甚至丝毫不用动，原因就是JDBC提供统一接口，每个数据库提供各自的实现，用一个叫做数据库驱动的程序来桥接就行了

```java
public interface Sourceable {
	public void method();
}

public class SourceSub1 implements Sourceable {
	@Override
	public void method() {
		System.out.println("this is the first sub!");
	}
}

public class SourceSub2 implements Sourceable {
 
	@Override
	public void method() {
		System.out.println("this is the second sub!");
	}
}

public abstract class Bridge {
	private Sourceable source;
 
	public void method(){
		source.method();
	}
	
	public Sourceable getSource() {
		return source;
	}
 
	public void setSource(Sourceable source) {
		this.source = source;
	}
}

public class MyBridge extends Bridge {
	public void method(){
		getSource().method();
	}
}

public class BridgeTest {
	
	public static void main(String[] args) {
		
		Bridge bridge = new MyBridge();
		
		/*调用第一个对象*/
		Sourceable source1 = new SourceSub1();
		bridge.setSource(source1);
		bridge.method();
		
		/*调用第二个对象*/
		Sourceable source2 = new SourceSub2();
		bridge.setSource(source2);
		bridge.method();
	}
}

```


## 六、组合模式

> 组合模式有时又叫部分-整体模式在处理类似树形结构的问题时比较方便



## 七、享元模式

> 享元模式的主要目的是实现对象的共享，即共享池，当系统中对象多的时候可以减少内存的开销，通常与工厂模式一起使用。

* 建立一个池的概念，实现对象的共享，来减少大量创建对象的内存开销