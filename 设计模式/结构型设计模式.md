# 七种结构型设计模式


- [七种结构型设计模式](#%e4%b8%83%e7%a7%8d%e7%bb%93%e6%9e%84%e5%9e%8b%e8%ae%be%e8%ae%a1%e6%a8%a1%e5%bc%8f)
  - [一、适配器模式(Adapter)](#%e4%b8%80%e9%80%82%e9%85%8d%e5%99%a8%e6%a8%a1%e5%bc%8fadapter)
    - [1. 类的适配器](#1-%e7%b1%bb%e7%9a%84%e9%80%82%e9%85%8d%e5%99%a8)
    - [2. 对象适配器](#2-%e5%af%b9%e8%b1%a1%e9%80%82%e9%85%8d%e5%99%a8)
    - [3. 接口适配器](#3-%e6%8e%a5%e5%8f%a3%e9%80%82%e9%85%8d%e5%99%a8)
  - [二、装饰模式(Decorator)](#%e4%ba%8c%e8%a3%85%e9%a5%b0%e6%a8%a1%e5%bc%8fdecorator)
  - [三、代理模式(Proxy)](#%e4%b8%89%e4%bb%a3%e7%90%86%e6%a8%a1%e5%bc%8fproxy)
  - [四、外观模式(Facade)](#%e5%9b%9b%e5%a4%96%e8%a7%82%e6%a8%a1%e5%bc%8ffacade)
  - [五、桥接模式(Bridge)](#%e4%ba%94%e6%a1%a5%e6%8e%a5%e6%a8%a1%e5%bc%8fbridge)
  - [六、组合模式](#%e5%85%ad%e7%bb%84%e5%90%88%e6%a8%a1%e5%bc%8f)
  - [七、享元模式](#%e4%b8%83%e4%ba%ab%e5%85%83%e6%a8%a1%e5%bc%8f)

>参考文章：https://blog.csdn.net/zhangerqing/article/details/8239539 
https://blog.csdn.net/lovelion/article/details/17517213?tdsourcetag=s_pctim_aiomsg

## 一、适配器模式(Adapter)

>适配器模式将某个类的接口转换成客户端期望的另一个接口表示，目的是消除由于接口不匹配所造成的类的兼容性问题。主要分为三类：类的适配器模式、对象的适配器模式、接口的适配器模式


### 1. 类的适配器


### 2. 对象适配器


### 3. 接口适配器





## 二、装饰模式(Decorator)

>装饰模式就是给一个对象增加一些新的功能，而且是动态的，要求装饰对象和被装饰对象实现同一个接口，装饰对象持有被装饰对象的实例



## 三、代理模式(Proxy)

>代理模式就是多一个代理类出来，替原对象进行一些操作，比如我们在租房子的时候回去找中介，为什么呢？因为你对该地区房屋的信息掌握的不够全面，希望找一个更熟悉的人去帮你做，此处的代理就是这个意思。再如我们有的时候打官司，我们需要请律师，因为律师在法律方面有专长，可以替我们进行操作，表达我们的想法



- __代理模式和装饰模式的区别__

    PS：两个设计模式看起来很像。对装饰器模式来说，装饰者（decorator）和被装饰者（decoratee）都实现同一个 接口。对代理模式来说，代理类（proxy class）和真实处理的类（real class）都实现同一个接口。此外，不论我们使用哪一个模式，都可以很容易地在真实对象的方法前面或者后面加上自定义的方法。

    然而，实际上，在装饰器模式和代理模式之间还是有很多差别的。装饰器模式关注于在一个对象上动态的添加方法，然而代理模式关注于控制对对象的访问。换句话 说，用代理模式，代理类（proxy class）可以对它的客户隐藏一个对象的具体信息。因此，当使用代理模式的时候，我们常常在一个代理类中创建一个对象的实例。并且，当我们使用装饰器模 式的时候，我们通常的做法是将原始对象作为一个参数传给装饰者的构造器。

    我们可以用另外一句话来总结这些差别：使用代理模式，代理和真实对象之间的的关系通常在编译时就已经确定了，而装饰者能够在运行时递归地被构造。



## 四、外观模式(Facade)

> 为子系统中的一组接口提供一个统一的入口。外观模式定义了一个高层接口，这个接口使得这一子系统更加容易使用。外观模式就是将他们的关系放在一个Facade类中，降低了类类之间的耦合度，该模式中没有涉及到接口

外观模式又称为门面模式，它是一种对象结构型模式。__外观模式是迪米特法则的一种具体实现__，通过引入一个新的外观角色可以降低原有系统的复杂度，同时降低客户类与子系统的耦合度。


```java

public class CPU {    
    public void startup(){
        System.out.println("cpu startup!");
    }
}

public class Disk {    
    public void startup(){
        System.out.println("disk startup!");
    }
}

public class Computer {
    private CPU cpu;
    private Disk disk;
    
    public Computer(){
        cpu = new CPU();
        disk = new Disk();
    }
    
    public void startup(){
        System.out.println("start the computer!");
        cpu.startup();
        disk.startup();
        System.out.println("start computer finished!");
    }
}

```



## 五、桥接模式(Bridge)

>桥接模式就是把事物和其具体实现分开，使他们可以各自独立的变化。桥接的用意是：将抽象化与实现化解耦，使得二者可以独立变化，像我们常用的JDBC桥DriverManager一样，JDBC进行连接数据库的时候，在各个数据库之间进行切换，基本不需要动太多的代码，甚至丝毫不用动，原因就是JDBC提供统一接口，每个数据库提供各自的实现，用一个叫做数据库驱动的程序来桥接就行了

```java
public interface Sourceable {
    public void method();
}

public class SourceSub1 implements Sourceable {
    @Override
    public void method() {
        System.out.println("this is the first sub!");
    }
}

public class SourceSub2 implements Sourceable {
 
    @Override
    public void method() {
        System.out.println("this is the second sub!");
    }
}

public abstract class Bridge {
    private Sourceable source;
 
    public void method(){
        source.method();
    }
    
    public Sourceable getSource() {
        return source;
    }
 
    public void setSource(Sourceable source) {
        this.source = source;
    }
}

public class MyBridge extends Bridge {
    public void method(){
        getSource().method();
    }
}

public class BridgeTest {
    
    public static void main(String[] args) {
        
        Bridge bridge = new MyBridge();
        
        /*调用第一个对象*/
        Sourceable source1 = new SourceSub1();
        bridge.setSource(source1);
        bridge.method();
        
        /*调用第二个对象*/
        Sourceable source2 = new SourceSub2();
        bridge.setSource(source2);
        bridge.method();
    }
}

```


## 六、组合模式

> 组合模式有时又叫部分-整体模式在处理类似树形结构的问题时比较方便



## 七、享元模式

> 享元模式的主要目的是实现对象的共享，即共享池，当系统中对象多的时候可以减少内存的开销，通常与工厂模式一起使用。

* 建立一个池的概念，实现对象的共享，来减少大量创建对象的内存开销