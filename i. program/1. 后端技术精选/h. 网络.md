# 网络

- [网络](#网络)
  - [一、网络模型](#一网络模型)
    - [1.1、七层网络模型](#11七层网络模型)
    - [1.2、四层网络模型](#12四层网络模型)
    - [1.3、三次握手、四次挥手](#13三次握手四次挥手)
    - [1.4、 黏包问题](#14-黏包问题)
    - [1.5、 零拷贝问题](#15-零拷贝问题)
    - [1.6、TCP的11种状态](#16tcp的11种状态)
  - [二、http、https协议](#二httphttps协议)
    - [2.1、什么是HTTP?](#21什么是http)
    - [2.2、http协议发展史](#22http协议发展史)
    - [2.3、http2的多路复用](#23http2的多路复用)
    - [2.4、http缓存](#24http缓存)
    - [2.5、http报文](#25http报文)
    - [2.6、http的状态码有哪些](#26http的状态码有哪些)
    - [2.7、https](#27https)
    - [2.8、https的握手过程](#28https的握手过程)
    - [2.9、HTTPS 握手过程中，客户端如何验证证书的合法性](#29https-握手过程中客户端如何验证证书的合法性)
    - [2.10、https的对称加密和非对称加密](#210https的对称加密和非对称加密)
    - [2.11、https的安全性](#211https的安全性)
    - [2.12、HTTP方法具体作用](#212http方法具体作用)
    - [2.13、GET和POST有什么区别？](#213get和post有什么区别)
    - [2.14、PUT和POST有什么区别？](#214put和post有什么区别)
    - [2.15、HTTP的keep-alive是干什么的？](#215http的keep-alive是干什么的)
    - [2.16、tcp、udp区别](#216tcpudp区别)
  - [三、web知识](#三web知识)
    - [3.1、cookie && session && token](#31cookie--session--token)
  - [四、网络相关排查应用](#四网络相关排查应用)
    - [4.1、排查服务器有多少tcp连接](#41排查服务器有多少tcp连接)
  - [参考文章](#参考文章)

## 一、网络模型

### 1.1、七层网络模型

- 物理层
  - 网线、海底电缆等让电脑之间可以连接起来，传输0/1的电路信号


### 1.2、四层网络模型
根据七层网络模型简化为四层IP/TCP网络模型

- 数据链路层
  - 把0/1的电路信号进行分组描述。一组信号是一个数据包，叫一个帧，帧又分为标头和数据，标头包含一些说明性的东西，比如发送者，接收者，数据类型
  - 以太网协议规定，接入网络里的所有设备必须有一个网卡，网卡地址就是所谓的mac地址，每块网卡出厂时就有一个唯一的mac地址，48位的二进制， 
  - 介绍：
     - 很多年前,每个公司都定义自己的电路信号分组方式,但是后来出来了以太网协议。
     - 一组电信号是一个数据包,叫一个帧(tame),每个帧分成两个部分,标头(head)和数据(data)，标头包含一些说明性的东西,比如说发送者、接收者和数据类型之类的
     - 每台电脑要往另外一台电脑发送数据,一堆0/1电路信号,封装成数据包,包含头和数据,头里包含了从哪儿来到哪儿去，必须从一台电脑的一个网卡，发送到另外一个电脑的一个网卡，所以以太网发送的数据包必须得指定，目标电脑的网卡的mac地址。
     - 以太网规定了,每个网卡必须得包含一个mc地址,mac地址就是这个网卡的唯一标识,以太网协议规定了,接入网备里的所有设备,都得有个网卡,以太网协议里的那个数据包在数据链路传输里,必须从一个电脑的网卡传输到另外一个电脑的网卡,而这个网卡地址就叫做所谓的mac地址。每块网卡出厂的时候,就有一个唯一的mac地址,48位的二进制,但是一般用12个16进制数字表示,前6个16进制是厂商编号,后6个16进制是网卡流水号
    - windows上, ipconfig/all",看看物理地址,就是mac地址,7c674220AB5C 所以在以太网里传输数据包的时候,必须指定接收者的mc地址才能传输数据。
    - 但是以太网的数据包怎么从一个mac地址发送到另一个mac地址?这个不是精准推送的,以太网里面,如果一个电脑发个数据包出去，会广播给局域网内的所有电脑设备的网卡，然后每台电脑都从数据包里获取接收者的 mac 地址，跟自己的 mac 地址对比一下，如果一样，就说明这是发给自己的数据包。 但是上面这种广播的方式，仅仅针对一个子网（局域网）内的电脑会广播

- 网络层
  
  - 子网内的电脑，通过以太网发个数据包，对局域网内的电脑，是广播出去的。那么怎么知道哪些电脑在一个子网内呢？这就得靠网络层了，这里就有一套 IP 地址，IP 地址就可以让我们区分哪些电脑是一个子网的。 
  - 网络层里有 IP 协议，IP 协议定义的地址就叫做 IP 地址。IP 地址有 IPv4 和 IPv6 两个版本，目前广泛使用的是 IPv4，是 32 个二进制数字组成的，但是一般用 4 个十进制数字表示，范围从 0.0.0.0 到 255.255.255.255 之间。 
  - 每台计算机，都会分配一个 ip 地址，ip地址的前24位（就是前面3个十进制数字），代表了网络，后8位（就是最后1个十进制数字），代表了主机。
  - 如果几台电脑是一个子网的，那么前面的 3 个十进制数字一定是一样的。举个例子，大家平时做实验，玩儿虚拟机吧，自己 win 上开几个 linux 虚拟机，你会发现，win上的ip地址可能是 192.168.0.103，然后几个虚拟机的ip地址是192.168.0.182，192.168.0.125，192.168.0.106，类似这样的。
  - 这个 win 机器和几个虚拟机，前面3个十进制数字都是192.168.0，就代表大家是一个子网内的，最后那个数字是这个子网的不同主机的编号。
  - 但是实际上上面就是举个例子，其实单单从ip地址是看不出来哪些机器是一个子网的，因为从10进制是判断不出来的。需要通过 ip 地址的二进制来判断，结合一个概念来判断，叫做子网掩码。
  - 判断两个 ip 地址是不是一个子网，比如说 ip 地址是192.168.56.1，子网掩码是 255.255.255.0。知道了子网掩码之后，如果要判断两个 ip 地址是不是一个子网的，就分别把两个 ip 地址和自己的子网掩码进行二进制的 与 运算，与运算之后，比较一下代表网络的那部分。11111111.11111111.11111111.00000000，然后就跟 ip 地址的二进制做 与运算，通过二进制来比较网络部分的地址是不是一模一样的。 有了网络层的 ip 地址之后，两台在子网内的电脑终于可以通过 广播 + mac 地址判断来传输数据包进行通信了。

- 传输层
  - 网络层是基于ip协议，进行主机和主机间寻址通信的，传输层其实是建立在主机的端口上，是通过socket来实现的，udp和tcp都是传输层的协议，  
  - 所以其实大家会发现一点，网络层，是基于ip协议，进行主机和主机间的寻址和通信的，然后传输层，其实是建立某个主机的某个端口，到另外一个主机的某个端口的连接和通信的。
  - 这个通信，就是通过 socket 来实现的，通过 socket 就可以基于 tcp/ip 协议完成刚才上面说的一系列的比如基于ip 地址和 mac 地址转换和寻址啊，通过路由器通信啊之类的，而且会建立一个端口到另外一个端口的连接。
  - udp 和 tcp 都是传输层的协议，作用就是在数据包里加入端口号，可以通过端口号进行点对点的通信了。
  - udp 协议是不可靠的，发出去人家收到没有就不知道了；tcp协议是可靠的，要求三次握手，而且要求人家接收到数据必须回复你

- 应用层
  - 应用层就是对tcp/udp进行解析，处理，常见的有http/ftp协议


### 1.3、三次握手、四次挥手
- __三次握手__
  ```
  握手过程:
      发送端 -> 接收端  你听得到吗？
      接收端 -> 发送端  我听到的到，你听的到我吗？
      发送端 -> 接收端  我听的到，我们开始说话吧
  具体过程
      发送端发送当前seq（发送端序号）x 发送给当前接收端（发送SYN表识数据包）
      接收端返回ack（确认序号）x+1,seq(接收端序号) y 给发送端（发送SYN表识数据包）
      发送单发送ack（确认序号）y+1给接收端（发送ACK表识数据包）
  ```
- 为什么要三次握手
  - 如果不确认一次，那么我们发送如果网络不好那么服务端一直开着一个链接，客户端过了一会又发了一个信息，那么服务器端认为是一个新端请求就会创建一个新的链接，造成了不必要的性能的开销，三次握手就表示双方都收到，就不会出现上面的问题了


- __四次挥手__
  ```
  分手过程
      客户端 -> 服务器 请求关闭链接
      服务器 -> 客户端 确认到关闭
      服务器 -> 客户端 我要关闭了，你确认一下
      客户端 -> 服务端 我关闭了，你也关闭吧，不用回复了 
  具体过程
      客户端发送seq x+2（序号）ACK y+1 （确认序号）给服务端（FIN包）
      服务器发送ACK（确认序号）x+1（ACK包）
      服务器发送seq y+1 （序号）（FIN包）
      客户端发送ACK（确认序号）y+2
  ```


- 为什么要四次挥手
  - 由于我们的tcp是双向的，我们客户端发送给服务端说可以断开链接了，但是可能我们的服务端端数据还没有发送完成，所以需要进行一次确认，我们服务端发送一个ACK确认包给客户端，（我收到了），然后服务端再发送一个FIN包（我已经传输完毕了），可以断开链接了，然后客户端确认到关闭端请求，给服务端发送收到端消息，双方就关闭了。


### 1.4、 黏包问题

- __什么是黏包？__
  - TCP粘包是指发送方发送的若干包数据到接收方接收时粘成一包，从接收缓冲区看，后一包数据的头紧接着前一包数据的尾。

  - 出现粘包现象的原因是多方面的，它既可能由发送方造成，也可能由接收方造成。

  - TCP和UDP分别是面向连接和非面向连接的。因此TCP的socket编程，收发两端（客户端和服务器端）都要有成对的socket，因此，发送端为了将多个发往接收端的包，更有效的发到对方，使用了优化方法（Nagle算法），将多次间隔较小、数据量小的数据，合并成一个大的数据块，然后进行封包。这样，接收端，就难于分辨出来了，必须提供科学的拆包机制。

  - 对于UDP，不会使用块的合并优化算法，这样，实际上目前认为，是由于UDP支持的是一对多的模式，所以接收端的skbuff(套接字缓冲区）采用了链式结构来记录每一个到达的UDP包，在每个UDP包中就有了消息头（消息来源地址，端口等信息），这样，对于接收端来说，就容易进行区分处理了。所以UDP不会出现粘包问题。

- __如何解决黏包？__
  - 对于发送方引起的粘包现象，用户可通过编程设置来避免，TCP提供了强制数据立即传送的操作指令push，TCP软件收到该操作指令后，就立即将本段数据发送出去，而不必等待发送缓冲区满；
  - 对于接收方引起的粘包，则可通过优化程序设计、精简接收进程工作量、提高接收进程优先级等措施，使其及时接收数据，从而尽量避免出现粘包现象；
  - 由接收方控制，将一包数据按结构字段，人为控制分多次接收，然后合并，通过这种手段来避免粘包。

- __合理解决黏包方案-分包算法__
  - 分包算法分别采取了相应的解决办法。其基本思路是首先将待处理的接收数据流（长度设为m）强行转换成预定的结构数据形式，并从中取出结构数据长度字段，即图5中的n，而后根据n计算得到第一包数据长度
    ```
    1)若n<m，则表明数据流包含多包数据，从其头部截取n个字节存入临时缓冲区，剩余部分数据依此继续循环处理，直至结束。

    2)若n=m，则表明数据流内容恰好是一完整结构数据，直接将其存入临时缓冲区即可。

    3)若n>m，则表明数据流内容尚不够构成一完整结构数据，需留待与下一包数据合并后再行处理。
    ```

### 1.5、 零拷贝问题
- 一般文件传输过程
  - 考虑这样一种常用的情形：开发者需要将静态内容（类似图片、数据表、文件）展示给远程的用户。那么这个情形就意味着开发者需要先将静态内容从磁盘中拷贝出来放到一个内存buf中，然后将这个buf通过 socket！传输给用户，进而用户或者静态内容的展示。这看起来再正常不过了，但是实际上这是很低效的流程，我们把上面的这种情形抽象成下面的过程。
    ```java
    read(file, tmp buf, len);
    write( socket, tmp buf, len);
    ```
  ![](https://gitee.com/jingxuanye/yjx-pictures/raw/master/pic/20200628153719.png)

  - 先调用read将静态内容，这里假设为数据文件A，读取到 tmp buf。然后调用wrte将tmp入到 socket中
    ```java
    在这个过程中数据文件A的经历了4次复制的过程
    首先，调用read时，数据文件A拷贝到了 kernel模式；之后，CPU控制将 kernel模式数据复制到user模式下
    调用rite时，先将user模式下的内容复制到到 kernel模式下的 socke的 buffer中最后将 kernel模式下的 socket buffer的数据复制到网卡设备中传送
    ```

  - 从上面的过程可以看出，数据白白从 kernel模式到use「模式走了一圏，浪费了2次opy（第一次，从 kernel模式拷贝到user模式；第二次从user模式再拷贝回 kernel模式，即上面4次过程的第2和3步骤）。而且上面的过程中 kernel和user模式的上下文的切换也是4次。

- 零拷贝
  - 开发者可以用“零拷贝”技术来去掉这些无谓的复制。应用程序用Zero-Copy来请求kernel直接把disk的data传输给 socket，而不是通过应用程序传输。Zero-Copy大大提高了应用程序的性能，并且减少了 kernel和user模式上下文的切换

  - linux中“零拷贝” 机制使用了sendfile方法，减少了 kernel和user模式上下文的切换
  ![](https://gitee.com/jingxuanye/yjx-pictures/raw/master/pic/20200529154950.png)
  - 所谓“零拷贝”就是跳过“用户缓冲区”的拷贝，建立一个磁盘空间和内存的直接映射，数据不再复制到“用户态缓冲区


### 1.6、TCP的11种状态


## 二、http、https协议

### 2.1、什么是HTTP?

超文本传输协议，是一个基于请求与响应，无状态的，应用层的协议，常基于TCP/IP协议传输数据，互联网上应用最为广泛的一种网络协议,所有的WWW文件都必须遵守这个标准。设计HTTP的初衷是为了提供一种发布和接收HTML页面的方法。

### 2.2、http协议发展史

- HTTP/0.9
  - 1991年，不涉及数据包的传输，规定客户端和服务器之间通信格式，只能get请求。没有做为正式标准

- HTTP/1.0
  - 1996年，传输内容格式不受限制，HTTP1.0定义了三种请求方法： GET, POST 和 HEAD方法。正式作为标准

- HTTP/1.1
  - 1997年，增加持久连接，节约贷款，host域，管道机制，分块传输，新增了五种请求方法：OPTIONS, PUT, DELETE, TRACE 和 CONNECT。2015年使用最为广泛

- HTTP/2.0
  - 2015年，多路复用，服务器推送，头信息压缩，二进制协议等。逐渐覆盖市场

- http2和http1.1之间的区别
  - http2 是二进制传输
  - 头部压缩，http1.1每次都要重复请求大量都头部信息，http2只需要发送改变都头部信息就可以
  - 服务器推送：服务器可以在推送html的时候主动推送其他的一些资源
  - 多路由复用：http1.1比如我们请求2个文件，一个文件请求需要1秒，第二个文件需要等待第一个请求响应结束，才可以进行三次握手传递文件，那么时间就会增加，而http2中按流等形式进行传输，帧是流等最小单位，帧中带有下标，可以识别从哪个流来的，服务器会将帧数据重新整合成流，也就是多路由复用

### 2.3、http2的多路复用

http/1每次请求都会建立一次tcp链接，也就是我们说的三次握手四次挥手。这个过程是非常耗时的，尽管可以开启keep-alive去避免多次连接的问题。但是还是存在一下两个问题：

- 1、串行的文件传输方式。文件传输的过程是，当a文件传输时，b文件只能等待。而a文件在传输过程中，需要经历连接服务，服务器处理文件，以及断开服务等三个过程。假设每个过程耗时1s，那么a文件耗时就是3s，那么b文件传输完成就是6s
- 2、连接数过多。当客户端发起多个请求时，浏览器会对请求的并发数做一个限制，chrome的最大并发数是6个，那么第7个请求的时候就需要等前面的请求完成之后，才能拿到相应的结果。
- 3、而http2之后，改成了二进制传输，也就多了帧和流的概念。
- 4、数据在一个tcp连接中按流的形式传输，帧就是其中最小的传输单位，而帧中带有标示位，可以识别是从哪个流中来的，到服务端之后，服务端会将帧数据重新整合成流，也就是所说的多路复用。

### 2.4、http缓存
- 强缓存
  - 强缓存就是浏览器缓存，资源直接从浏览器中获取。
  - 分为两类from memory cache,from disk cache。返回的状态码都为200.
  - 两者的区别是from memory cache是从内存中取。from disk cache是从硬盘中取。如果是刷新当前页面，且内存环境比较充裕的情况下，返回from memory cache。但是如果是返回上一个页面或者当前内存环境不充裕的情况下，返回的是from disk cache。
  - 强缓存的判断标志有两个，Expires这个标识实在http1.0之前用的，表示的是过期时间，但是客户端和服务端时间存在不同步问题，所以在http1.1之后加入了Cache-Control，这个表示的是距离请求发出时的时间，是一个相对时间比较精确

- 协商缓存
  - 就是资源会从cdn去获取。
  - 协商缓存的判断标识：Last-Modified和ETag。ETag是文件每次生成的hash，是唯一的准确性高，但是比较繁琐以及消耗性能。而Last-Modified是以秒级为单位的文件生成时间，比较不精确。因为1s中文件可能多次生成。判断的优先标准是ETag。其次是Last-Modified。

- http缓存的判断过程：
  - 先判断Cache-Control的值，这里不细讲，比如max-age=300，那么在五分钟之内都会触发强缓存。如果已经过了5分钟之后，会进入协商缓存阶段。发出去的http请求中会带有两个标示位， If-Modified-Since(来自第一次请求返回头中的Last-Modified)和If-None-Match（来自第一次请求返回头中的ETag）。两个标示位的区别我在上面已经说了，根据标示位判断文件是否更新，如果更新返回状态码200以及资源。如果没有更新，只返回状态码304

- 有了【Last-Modified，If-Modified-Since】为何还要有【ETag、If-None-Match】
  - 当前时间（按秒来创建）可能会创建多个文件，所以时间可能会相同
hash值唯一不会相同

### 2.5、http报文
- 请求报文
  ```http
  请求行
  请求方式 请求路由 协议/版本
  post     /xx      http/1.1

  请求头
  accept */* //请求需要的格式
  user-agent //当前请求的浏览器信息
  host //ip || 域名
  空行 //分割主体和请求头

  请求体
  // json，fromData等
  ```
  ![](https://gitee.com/jingxuanye/yjx-pictures/raw/master/pic/20200629152831.png)

- 响应报文
  ```
  响应行
  响应头
  空行
  响应体
  ```
  ![](https://gitee.com/jingxuanye/yjx-pictures/raw/master/pic/20200629152959.png)


### 2.6、http的状态码有哪些
```http
1XX: 临时响应
2XX: 成功
    200:成功
    206:范围请求，比如最大需要200k的数据
3XX: 重定向
    301:永久重定向（不会保存之前的url 会使用新的url）
    302:临时重定向（保存之前的url 会使用新的url）
    304:强缓存还可以使用
401: 客户端错误
    400:请求错误（请求格式错误，请求头错误）
    401:需要登陆信息，需要验证身份
    403:拒绝访问
    404:没有当前资源
5XX: 服务端错误
    500:服务端发生流错误
    502:服务器错误，过载或者任务不可用
```

### 2.7、https
- 基于HTTP协议，通过SSL或TLS提供加密处理数据、验证对方身份以及数据完整性保护
- 而且HTTPS有如下特点：
  - 内容加密：采用混合加密技术，中间者无法直接查看明文内容
  - 验证身份：通过证书认证客户端访问的是自己的服务器
  - 保护数据完整性：防止传输的内容被中间人冒充或者篡改



### 2.8、https的握手过程
- 握手过程

  - 1、客户端发送请求给服务端
  - 2、服务器端拿着数字证书的公钥进行非对称加密，返回数字证书（公钥、证书信息、服务端信息、hash值）
  - 3、客户端收到服务端返回端数字证书，对数字证书进行校验（是否过期，是否正确）然后客户端生成随机数，与数字证书里的公钥进行对称加密，返回给服务端
  - 4、服务端用私钥对当前客户端的值进行解密，获取随机数、服务端把客户端需要的数据和随机数进行对称加密返回给客户端
  - 5、客户端收到数据，（通过随机数）进行对称解密，获取数据
  - 6、之后服务端与客户端就通过随机数的对称加密方式进行交互

  ![](https://gitee.com/jingxuanye/yjx-pictures/raw/master/pic/20200629182859.png)


- HTTP和HTTPS握手差异？
  - https需要ca证书
  - tcp链接http访问80端口，https访问443端口
  - http明文，https加密
  - https 要比 http 多了证书校验，增加了通信的加密，比http安全

### 2.9、HTTPS 握手过程中，客户端如何验证证书的合法性
拿到服务端给的数字签名之后，客户端会根据机构颁发的私钥对数字签名的东西进行解密。解密出来，内部会含有服务端信息和证书的信息。
证书信息需要校验以下几方面：
1、颁发证书的第三方机构（CA）是否受客户端的信任。
2、对比系统时间校验证书是否在有效期。
3、通过CRL或者OCSP的方式校验证书是否被吊销。
4、通过校验对方是否存在证书的私钥，判断证书的网站域名是否与证书颁发的域名一致。

### 2.10、https的对称加密和非对称加密
- 对称加密
  - 加解密钥匙是同一个，密钥在传输过程中容易被第三方截取，安全性相对较低。
- 非对称加密
  - 一共有一对钥匙，分为公钥和私钥。公钥进行加密过程，私钥用于解密过程。性能上相对于对称加密来的低
- 在https中的应用
  - 由于性能原因，https只有在第一次建立的时候会使用非对称加密，之后的过程都是走随机数的对称加密方式。


### 2.11、https的安全性
- HTTPS协议的加密范围也比较有限，在黑客攻击、拒绝服务攻击、服务器劫持等方面几乎起不到什么作用
- SSL证书的信用链体系并不安全，特别是在某些国家可以控制CA根证书的情况下，中间人攻击一样可行

- 中间人攻击（MITM攻击）是指，黑客拦截并篡改网络中的通信数据。又分为被动MITM和主动MITM，被动MITM只窃取通信数据而不修改，而主动MITM不但能窃取数据，还会篡改通信数据。最常见的中间人攻击常常发生在公共wifi或者公共路由上。


### 2.12、HTTP方法具体作用
- GET: 通常用于请求服务器发送某些资源
- HEAD: 请求资源的头部信息, 并且这些头部与 HTTP GET 方法请求时返回的一致. 该请求方法的一个使用场景是在下载一个大文件前先获取其大小再决定是否要下载, 以此可以节约带宽资源
- OPTIONS: 用于获取目的资源所支持的通信选项
- POST: 发送数据给服务器
- PUT: 用于新增资源或者使用请求中的有效负载替换目标资源的表现形式
- DELETE: 用于删除指定的资源
- PATCH: 用于对资源进行部分修改
- CONNECT: HTTP/1.1协议中预留给能够将连接改为管道方式的代理服务器
TRACE: 回显服务器收到的请求，主要用于测试或诊断

### 2.13、GET和POST有什么区别？
- 数据传输方式不同：GET请求通过URL传输数据，而POST的数据通过请求体传输。
- 安全性不同：POST的数据因为在请求主体内，所以有一定的安全性保证，而GET的数据在URL中，通过历史记录，缓存很容易查到数据信息。
- 数据类型不同：GET只允许 ASCII 字符，而POST无限制
- GET无害： 刷新、后退等浏览器操作GET请求是无害的，POST可能重复提交表单
- 特性不同：GET是安全（这里的安全是指只读特性，就是使用这个方法不会引起服务器状态变化）且幂等（幂等的概念是指同一个请求方法执行多次和仅执行一次的效果完全相同），而POST是非安全非幂等

### 2.14、PUT和POST有什么区别？
- PUT 和POST方法的区别是,PUT方法是幂等的：连续调用一次或者多次的效果相同（无副作用），而POST方法是非幂等的。
- 除此之外还有一个区别，通常情况下，PUT的URI指向是具体单一资源，而POST可以指向资源集合。


### 2.15、HTTP的keep-alive是干什么的？
- 在早期的HTTP/1.0中，每次http请求都要创建一个连接，而创建连接的过程需要消耗资源和时间，为了减少资源消耗，缩短响应时间，就需要重用连接。在后来的HTTP/1.0中以及HTTP/1.1中，引入了重用连接的机制，就是在http请求头中加入Connection: keep-alive来告诉对方这个请求响应完成后不要关闭，下一次咱们还用这个请求继续交流。协议规定HTTP/1.0如果想要保持长连接，需要在请求头中加上Connection: keep-alive。

- keep-alive的优点：
  - 较少的CPU和内存的使用（由于同时打开的连接的减少了）
  - 允许请求和应答的HTTP管线化
  - 降低拥塞控制 （TCP连接减少了）
  - 减少了后续请求的延迟（无需再进行握手）
  - 报告错误无需关闭TCP连接

### 2.16、tcp、udp区别
- TCP面向连接（如打电话要先拨号建立连接）;UDP是无连接的，即发送数据之前不需要建立连接
- TCP提供可靠的服务。也就是说，通过TCP连接传送的数据，无差错，不丢失，不重复，且按序到达;UDP尽最大努力交付，即不保证可靠交付。Tcp通过校验和，重传控制，序号标识，滑动窗口、确认应答实现可靠传输。如丢包时的重发控制，还可以对次序乱掉的分包进行顺序控制。
- UDP具有较好的实时性，工作效率比TCP高，适用于对高速传输和实时性有较高的通信或广播通信。
- 每一条TCP连接只能是点到点的;UDP支持一对一，一对多，多对一和多对多的交互通信
- TCP对系统资源要求较多，UDP对系统资源要求较少。



## 三、web知识

### 3.1、cookie && session && token

- cookie
  - 储存在用户本地终端上的数据
  - 由于“Cookie”具有可以保存在客户机上的神奇特性, 因此它可以帮助我们实现记录用户个人信息的功能
  - Cookie是一段不超过4KB的小型文本数据，由一个名称（Name）、一个值（Value）和其它几个用于控制Cookie有效期、安全性、使用范围的可选属性组成

- session
  - 在网络应用中，称为“会话控制”，Session对象存储特定用户会话所需的属性及配置信息。这样，当用户在应用程序的Web页之间跳转时，存储在Session对象中的变量将不会丢失，而是在整个用户会话中一直存在下去
  - cookie 和session的区别是：
    - cookie数据保存在客户端，session数据保存在服务器端
    - cookie不是很安全，别人可以分析存放在本地的COOKIE并进行COOKIE欺骗,如果主要考虑到安全应当使用session
    - 将登陆信息等重要信息存放为SESSION;其他信息如果需要保留，可以放在COOKIE中
    - Cookie支持跨域名访问，例如将domain属性设置为“.biaodianfu.com”，则以“.biaodianfu.com”为后缀的一切域名均能够访问该Cookie。跨域名Cookie如今被普遍用在网络中，例如Google、Baidu、Sina等。而Session则不会支持跨域名访问。Session仅在他所在的域名内有效


- token
  - token可以理解为一个令牌，用户用户身份验证，
  - token采用三段组成, 标准token:   eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VyTmFtZSI6IuW8oOS4iSIsInVpZCI6IvCeiYAiLCJleHAiOjE2MDc2Njk0MDUsImlzcyI6ImRpaXQudG9wIiwibmJmIjoxNjA3NjU0NzA1fQ.mJ2G745yc03WS4inAP8mlolPof4ahX8AX_MPomfcO7k
  - 这三部分依次是头部（Header）、负载（Payload）、签名（Signature），
  - Header 中存储了所使用的加密算法和 Token 类型
  - Payload 是负载，可以自己指定字段和内容，一般存储用户信息，需要注意的是，Payload的内容只经过了 Base64 编码，对客户端来说当于明文存储，所以不要放置敏感信息
  - Signature 部分用来验证 JWT Token 是否被篡改，所以这部分会使用一个 Secret 将前两部分加密，逻辑如下


## 四、网络相关排查应用

### 4.1、排查服务器有多少tcp连接
```
一、查看哪些IP连接本机
netstat -an
二、查看TCP连接数
1)统计80端口连接数
netstat -nat|grep -i "80"|wc -l

2）统计httpd协议连接数
ps -ef|grep httpd|wc -l

3）、统计已连接上的，状态为“established
netstat -na|grep ESTABLISHED|wc -l

4)、查出哪个IP地址连接最多,将其封了.
netstat -na|grep ESTABLISHED|awk {print $5}|awk -F: {print $1}|sort|uniq -c|sort -r +0n

netstat -na|grep SYN|awk {print $5}|awk -F: {print $1}|sort|uniq -c|sort -r +0n
```


## 参考文章
- [面试 | 你要懂得http相关](https://juejin.im/post/5ea6dcacf265da7c026bd1d1)
- [一篇文章彻底了解HTTP发展史](https://cloud.tencent.com/developer/article/1513007)
- [中华石杉系列](https://github.com/shishan100/Java-Interview-Advanced)